\documentclass[11pt, a4paper, oneside]{article}

\usepackage{indentfirst}

% hifenização e outras especificações para português
\usepackage[portuguese]{babel}
\usepackage{listings}
% para ter imagens, depois define a directoria de imagens
\usepackage{graphicx}
\graphicspath{{./imagens/}}
\usepackage[utf8]{inputenc}    

\usepackage{listings}
\usepackage{color}
 
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
numberstyle=\tiny,
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
keywordstyle=\color[rgb]{0,0,1},
basicstyle=\tiny,
commentstyle=\color[rgb]{0.133,0.545,0.133},
stringstyle=\color[rgb]{0.627,0.126,0.941},
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

% hiperligações
\usepackage{hyperref}
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black}

% escrever acentos e coisas do género sem que o latex se desoriente
\usepackage[utf8]{inputenc}

% para ter imagens, depois define a directoria de imagens
\usepackage{graphicx}
\graphicspath{{./imagens/}}

\usepackage[labelformat=simple]{caption}
\usepackage[labelformat=empty]{subcaption}

% para ter a informação de quantas páginas tem o documento
\usepackage{lastpage}

% definir o cabeçalho e rodapé
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[L]{\small{\textbf{Gestão de Campeonatos de Orientação}}}
\fancyhead[R]{\small{Processamento de Linguagens}}

% ter enumerações alinhadas
\usepackage{enumitem}

% escrever algoritmos
\usepackage[algoruled]{algorithm2e}

% definir comandos especiais
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex} %

\newcommand{\todo}[1] {\textcolor{BrickRed}{\begin{quote}#1\end{quote}}}

%\usepackage{listings}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% inicio do documento
\begin{document}
\title{Gestão de Campeonatos de Orientação}
\date{\today\\Universidade do Minho}
\author{
  Bruno Ferreira\\
  {\small A61055}\\
  \and
  Cláudia Oliveira\\
  {\small A60987}\\
  \and
  Vanessa Campos\\
  {\small A54801}\\
}

\maketitle

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.4\linewidth]{logo}
\end{center}
\end{figure}


\begin{abstract}

  O presente trabalho foi desenvolvido no âmbito da Unidade Curricular de Processamento de Linguagens e tem como principal objetivo o aumento da experiência na Linguagem Imperativa C, a capacidade de escrever Gramáticas Independentes de Contexto que satisfaçam a condição de LR(), a utilização de compiladores como o Lex/Yacc e o desenvolvimento de Processadores de Linguagem. De entre os variados temas, Gestão de Campeonatos de Orientação foi o tema escolhido pelo nosso grupo, para o desenvolvimento deste segundo trabalho prático. Ao longo deste relatório iremos explicar as Estruturas de Dados que foram implementadas para o desenvolvimento deste trabalho, bem como todas as decisões que foram tomadas ao longo do desenvolvimento deste projeto. 

\end{abstract}
\newpage

\tableofcontents
\listoffigures 

\newpage
\section{Introdução}

A Orientação é um desporto que tem como objetivo percorrer uma determinada distância, onde o atleta tem de obrigatoriamente passar pelos pontos que estão indicados no mapa que lhe é atribuído.

Neste contexto, o foco deste projeto passa pela gestão de campeonatos de orientação onde é necessário saber a informação das provas que são efetuadas, os participantes envolvidos e os tempos que cada atleta obteve, de modo a serem obtidas as classificações necessárias.

Um objetivo principal do projeto é a leitura de ficheiros onde estes tem uma configuração definida pelo ficheiro de configuração, depois a leitura do CSV com a informação dos jogadores e mais tarde o geramento de um página HTML onde é apresentada a informação tratada.

Para a implementação foi necessário a construção de gramáticas independentes de contexto, implementação de parses para cada ficheiro que necessário, e a utilização do lex e yacc para retirar a informação necessária.


\newpage
\section{Desenvolvimento}

\subsection{Contextualização do Problema}

Flex é uma ferramenta para gerar automaticamente analisadores léxicos, isto é, programas que reconhecem padrões léxicos num texto. O Flex é uma evolução da ferramenta Lex, mas com a caraterística de ser mais rápido que este (Fast Lex).

Yacc é utilizado para sistemas operacionais Unix, onde o seu principal objetivo e gerar analisadores sintáticos. No entanto o yacc tem de ser utilizado em conjunto com o lex, pois o yacc não consegue ler a partir de uma entrada de dados, daí a utilização  do lex para que este gere os tokens que mais tarde são usados pelo yacc para o processamento.

Gramática Independente de Contexto é uma gramática formal onde são definidas regras de produção da 
 V $\rightarrow$ W onde V é um símbolo não terminal e w um conjunto de símbolos terminais ou variáveis (W no entanto também pode ser nulo).

\subsection{Gestão de Campeonatos de Orientação}

Neste segundo trabalho de Processamento de Linguagens foi proposto a seleção de um projeto entre vários propostos. Após uma análise e chegada a uma concordância, o nosso grupo optou por escolher o tema de Gestão de Campeonato de Orientação.

Com este enunciado existem várias operações que ocorrem em simultâneo, e por isso existem vários ficheiros, como:
\begin{itemize}
\item Ficheiro de Resultados é um ficheiro CSV, onde são guardados os resultados obtidos em cada prova.

\item Ficheiro de Configuração é um ficheiro que vai definir o processamento a realizar, isto é quais as provas e os campos que vão ser tratados.
\end{itemize}

\subsection{Enunciado}

De uma maneira geral, para este trabalho pretende-se desenvolver os seguintes pontos:

\begin{itemize}
\item Especificação de uma gramática para a linguagem de comandos da consola;
\item Especificação de uma gramática para a linguagem de especificação de connfigurações;
\item Especificação de uma gramática para os ficheiros de resultados;
\item Desenvolver os respetivos parses;
\item Adicionar as ações semânticas necessárias,
\end{itemize}

\subsection{Descrição do Problema}

Utilizando o flex, yac e gramáticas independentes de contexto era necessário a desenvolvimento de uma aplicação, que permita o tratar ficheiros específicos e gere o HTML como os resultados pretendidos.

No entanto existem outros requisitos que permitem o bom funcionamento da aplicação. Deste modo, a aplicação deve possuir um ambiente de consola e implementar os seguintes comandos:
\begin{itemize}
\item \textbf{Carregar configuração} - Permite carregar o ficheiro de configuração;
\item \textbf{Carregar base de dados} - Carregar um ficheiro de dados previamente guardado;
\item \textbf{Carregar resultado de prova} - Carregar o ficheiro de resultados;
\item \textbf{Calcular Ranking} - Permite calcular o ranking de pontuação dos atletas;
\item \textbf{Gravar base de dados} - Guardar a informação que existem na memória num ficheiro;
\item \textbf{Sair} - Termina a aplicação.
\end{itemize}

É a partir daqui que os ficheiro de resultados e configuração são lidos e depois as operações são executadas. 

Antes de ser criado o HTML a aplicação tem de ser configurada.
A informação para tal é lida de um ficheiro de configuração onde nele são definidos os campos:
\begin{itemize}
\item \textbf{Titulo} - Titulo da prova em causa;
\item \textbf{nporvas} - Nº de provas a realizar;
\item \textbf{N} - Indicados do topN ;
\item \textbf{campos} - Ordem dos campos quando no CSV;
\item \textbf{score} - Pontuação obtida.
\end{itemize}

\newpage

\section{Desenvolvimento do Programa}
Um dos pressupostos da implementação deste projeto é o tratamento de diferente tipo de informação, foi decidido estruturar-se o projeto consoante as funções que cada ficheiro implica.
[INSERIR IMAGEM DOS FICHEIROS]

O desenvolvimento deste projeto passa assim a desenvolver três gramáticas independentes de contexto distintas: 
\begin{itemize}
\item Gramática para a linguagem de comandos da consola; 
\item Gramática para a linguagem de configurações;
\item Grámatica para ficheiros de resultados. 
\end{itemize}

Para a criação das estruturas de dados foi usada a ferramenta \textit{gabs} disponibilizada pelo professor que cria a estrutura e os seus construtores quando é executada com uma gramática abstrata como argumento.

De modo a utiliza-se esta ferramenta era necessário, primeiramente, a criação de uma gramática abstrata. Por isso, uma das primeiras etapas deste projeto foi desenvolver a especificação de cada uma gramáticas independentes do contexto. 

Em cada uma das subsecções seguintes, será apresentada cada uma das gramáticas desenvolvidas, bem como a sua estrutura de dados implementada, as assinaturas das funções em C e os seus construtores.

\subsection{Especificação de Configurações da Aplicação}
O ficheiro de configurações define o processamento a realizar: campos a extrair para o resultado final, o número de provas que pontuam, o número de melhores resultados que serão contabilizados para a classificação, os campos que irão aparecer na página de resultado.

%%%%%%%%%%%%%%%%%%%%%%%%%%GRAMÁTICA-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Gramática para a Linguagem de Especificação de Configurações}

A gramática a apresentar é a usada para o ficheiro de configuração. Assim sendo tem-se:
\begin{lstlisting}[language=C, caption={Gramática para a linguagem de especificação de configurações.}]
<ga>
  Confs -> cons_cfg_Confs(Conf Confs)
        |  cons_cfg_Confs_NIL()
        ;

  Conf -> cons_cfg_Conf_Titulo(STR)
       |  cons_cfg_Conf_Nprovas(INT)
       |  cons_cfg_Conf_Ntop(INT)
       |  cons_cfg_Conf_Campos(Lcampos)
       |  cons_cfg_Conf_Tempo(INT)
       |  cons_cfg_Conf_Chave(INT)
       |  cons_cfg_Conf_Nome(INT)
       ;

  Lcampos -> cons_cfg_Lcampos_Lcampos(Lcampos INT)
          |  cons_cfg_Lcampos_Campo(INT)
          ;
</ga>
\end{lstlisting}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%ESTRUTURAS-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Estrutura de Dados da Especificação de Configurações}
A estrutura que é gerada para o armazenamento dos campos que a gramática abstrata definiu, é divida consoante o nível em que se esta. Assim, começa-se pela estrutura que vai abragir mais campos, neste caso o total de configurações, depois pela configuração, e, por último, a estrutura que vai guardar um campo para uma configuração.

\begin{lstlisting}[language=C, caption={Estrutura de dados para armazenar as configurações.}]
struct sConfs 
{ int flag;
  union {  
    struct {
        Conf s1;
        Confs s2;
      } d1;
    struct {
      } d2;

  } u;
};
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Estrutura de dados que armazena uma configuração.}]
struct sConf 
{ int flag;
  union {  
    struct {
        char * s1;
      } d1;
    struct {
        int s1;
      } d2;
    struct {
        int s1;
      } d3;
    struct {
        Lcampos s1;
      } d4;
    struct {
        int s1;
      } d5;

  } u;
};
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Estrututura de dados que armazena os campos de um configuração.}]
struct sLcampos 
{ int flag;
  union {  
    struct {
        Lcampos s1;
        int s2;
      } d1;
    struct {
        int s1;
      } d2;

  } u;
};
\end{lstlisting}

Verifica-se aqui que cada \textit{struct} acima apresentada deriva de cada uma das produções que foram indicadas em na gramática abstrata.
\newpage
\subsubsection{Assinatura das funções utilizadas}
Aqui serão apresentadas as assinaturas das funções que foram utilizadas para nós dar suporte à implementação do nosso projecto.

\begin{lstlisting}[language=C, caption={Construtores do ficheiro de configuração.}]
/* -----------------------------------
 * Constructor Function Signatures
 * -----------------------------------
 */

Confs  cons_cfg_Confs( Conf a1, Confs a2);
Confs  cons_cfg_Confs_NIL();

Conf  cons_cfg_Conf_Titulo( char * a1);
Conf  cons_cfg_Conf_Nprovas( int a1);
Conf  cons_cfg_Conf_Ntop( int a1);
Conf  cons_cfg_Conf_Campos( Lcampos a1);
Conf  cons_cfg_Conf_Tempo( int a1);
Conf  cons_cfg_Conf_Chave( int a1);
Conf  cons_cfg_Conf_Nome( int a1);

Lcampos  cons_cfg_Lcampos_Lcampos( Lcampos a1, int a2);
Lcampos  cons_cfg_Lcampos_Campo( int a1);
\end{lstlisting} 

Os construtores da aplicação são criados automaticamente, isto é, é passado ao \textit{gabs} a gramática abstrata criada. Esta ferramenta para além de criar as estrutura de dados, cria também todos os construtores necessários para a criação da mesma.

\begin{lstlisting}[language=C, caption={Funções do ficheiro de configuração.}]
/* -----------------------------------
 * Custom Function Signatures
 * -----------------------------------
 */
void cfg_Confs_print( Confs cfgs );
int cfg_Confs_validate( Confs cfgs );
Lcampos cfg_Lcampos_reverse( Lcampos l );

// getters
int cfg_get_Nprovas( Confs cfgs );
int cfg_get_Ntop( Confs cfgs );
int cfg_get_Tempo( Confs cfgs );
int cfg_get_Chave( Confs cfgs );
int cfg_get_Nome( Confs cfgs );
char* cfg_get_Titulo( Confs cfgs );

// obtem um array de inteiros com os campos. terminado com -1
int* cfg_get_Campos( Confs cfgs );
int cfg_get_NCampos( Confs cfgs );

// obtem um array de bytes que esta a 1 nos campos que foram selecionados
char* cfg_Campos_seleccionado( Confs cfgs, int totalCampos );
\end{lstlisting} 

Embora já estejam os construtores definidos automaticamente era necessário criar novas funções para ser possível manusear a estrutura de dados. Deste modo, foram criadas funções que permitem ir "buscar" algum campo específico, ou fazer operações como de validação, imprimir, entre outras.

\textbf{Nota:} Foi necessário desenvolver a função \texttt{Lcampos cfg\_Lcampos\_reverse( Lcampos l )}, uma vez que a gramática definida neste programa tem recursividade à esquerda e era necessário imprimir os valores pela ordem correta, daí a necessidade da criação desta função.

\begin{lstlisting}[language=C, caption={Funções de libertação de memória.}]
/* -----------------------------------
 * Destructor Function Signatures
 * -----------------------------------
 */

void free_cfg_Lcampos( Lcampos campos );
void free_cfg_Conf( Conf cfg );
void free_cfg_Confs( Confs cfgs );
\end{lstlisting} 

Foi implementando a funções de libertação de memória para garantir que toda a memória, que inicialmente foi feita, o malloc, existe um free, garantindo assim que a aplicaçãos não tem qualquer tipo de memory leek.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%YACC-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{YACC}
No ficheiro do \textit{YACC} existe, para cada produção, que seja "apanhada", uma função correspondente para tratar o caso apanhado.

\begin{lstlisting}[language=C, caption={YACC do ficheiro de configuração.}]
%token TITULO NPROVAS NTOP CAMPOS TEMPO CHAVE NOME str num
%{
#include <stdio.h>
#include <stdlib.h>
#include "cfg.lib.h"

#define YYERROR_VERBOSE

extern unsigned int cfglineno;
extern int cfglex (void);
extern int gco_set_Config(Confs cfg);
extern void cfglex_destroy();
%}
%union{
    char* cfg_str;
    int cfg_num;
    
    Confs cfg_confs;
    Conf cfg_conf;
    Lcampos cfg_campos;
}
%type <cfg_str> str Titulo
%type <cfg_num> num Nprovas Ntop Tempo Campo Chave Nome
%start Z

%type <cfg_confs> Z Configuracoes
%type <cfg_conf> Configuracao
%type <cfg_campos> Lcampos Campos
%%
Z : Configuracoes '$' { $$ = $1;
                        cfglex_destroy();
                        if( gco_set_Config($$) == 0 )
                            YYACCEPT;
                        YYABORT; };

Configuracoes : Configuracao '\n' Configuracoes {$$ = cons_cfg_Confs($1,$3);}
              | { $$ = cons_cfg_Confs_NIL(); }
              ;

Configuracao : Titulo  { $$ = cons_cfg_Conf_Titulo($1); }
             | Nprovas { $$ = cons_cfg_Conf_Nprovas($1); }
             | Ntop    { $$ = cons_cfg_Conf_Ntop($1); }
             | Tempo { $$ = cons_cfg_Conf_Tempo($1); }
             | Campos  { $$ = cons_cfg_Conf_Campos($1); }
             | Chave { $$ = cons_cfg_Conf_Chave($1); }
             | Nome { $$ = cons_cfg_Conf_Nome($1); }
             ;

Titulo  : TITULO str     { $$ = $2; };
Nprovas : NPROVAS num    { $$ = $2; };
Ntop    : NTOP num       { $$ = $2; };
Campos  : CAMPOS Lcampos { $$ = cfg_Lcampos_reverse( $2 ); }
Tempo   : TEMPO '$' num  { $$ = $3; };
Chave   : CHAVE '$' num  { $$ = $3; };
Nome    : NOME '$' num   { $$ = $3; };


Lcampos : Lcampos ';' Campo { $$ = cons_cfg_Lcampos_Lcampos($1,$3); }
        | Campo             { $$ = cons_cfg_Lcampos_Campo($1); }
        ;

Campo : '$' num { $$ = $2; };

%%
int yyerror( char* s ){
    fprintf(stderr, "Line %d: %s\n", cfglineno, s);
    return 0;
}
\end{lstlisting} 

Para o ficheiro de configuração o Yacc apanha os campos relativos à configuração do ficheiro. Cada uma das produções trata de um caso específico relativo aos campos. Assim, genericamente existe um campo e uma lista de campos, sendo necessário adicioná-lo à lista, daí exitir \texttt{\$\$ = cons\_cfg\_Lcampos\_Lcampos(\$1,\$3); }
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%LEX-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{LEX}
\begin{lstlisting} 
%{
#define YY_NO_INPUT
#include <string.h>
#include "cfg.lib.h"
#include "cfg.tab.h"
%}
%option nounput
%option yylineno
%x ler_string
%x ler_numero
%x ler_tempo
%x campos
%%
"=titulo="  {BEGIN ler_string; return TITULO;}
"=nprovas=" {BEGIN ler_numero; return NPROVAS;}
"=ntop="    {BEGIN ler_numero; return NTOP;}
"=campos="  {BEGIN campos;     return CAMPOS;}
"=tempo="   {BEGIN ler_numero; return TEMPO;}
"=chave="   {BEGIN ler_numero; return CHAVE;}
"=nome="    {BEGIN ler_numero; return NOME;}

<ler_string>[^\n]+ {if(*cfgtext == ' ')
                        cfglval.cfg_str = strdup(cfgtext+1);
                    else
                        cfglval.cfg_str = strdup(cfgtext);
                    BEGIN 0;
                    return str;}
<ler_numero>\$     return '$';
<ler_numero>[0-9]+ {cfglval.cfg_num = atoi(cfgtext);
                    BEGIN 0;
                    return num;}

<campos>[0-9]+ { cfglval.cfg_num = atoi(cfgtext);
                 return num;}
<campos>\$     { return '$'; }
<campos>\;     { return ';'; }
<campos>\n     { BEGIN 0; return '\n'; }

<*><<EOF>>  return '$';

[\n]+       return '\n';

<*>[ \t] ;
<*>.     { /*printf("flex: %c (%d)\n", *cfgtext, *cfgtext);*/ }

%%

int cfgwrap(){
    return 1;
}
\end{lstlisting} 
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Especificação para a Linguagem de Comandos da Consola}
A aplicação deverá ter um ambiente de consola com alguns comandos básicos:
\begin{itemize}
\item \textbf{Carregar configuração}: o sistema inicializa-se sempre com esta operação. Esta operação está sempre disponível para ser possível alterar a configuração.
\item \textbf{Carregar base de dados}: o sistema carrega para memória o estado de um torneio previamente gravado.
\item \textbf{Carregar resultado de prova}: o sistema carrega e processa um ficheiro CSV. Como resultado desta operação produz um ficheiro HTML com a pontuação de cada atleta, ordenado por ordem descente de pontos.
\item \textbf{Calcular ranking}: em qualquer momento poderá ser invocada esta operação à qual o sistema responder com uma listagem em HTML do raking;
\item \textbf{Gravar base de dados}: o sistema guarda em memória o estado da aplicação.
\item \textbf{Sair}: o sistema termina a aplicação, se o estado atual não tiver sido previamente gravado deverá lançar um atleta e pedir configuração para prosseguir.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%GRAMÁTICA-CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Especificação para a Linguagem de Comandos da Consola}
A gramática apresentar é a usada para o funcionamento da aplicação em ambiente consola (CMD). Assim sendo tem-se:
\begin{lstlisting}[language=C, caption={Gramática para a linguagem de especificação para a linguagem de comandos de consola.}]
<ga>
  Cmds -> cons_Cmds(Cmd Cmds)
       |  cons_Cmds_NIL()
       ;

  Cmd -> cons_Cmd_Config(STR)
      |  cons_Cmd_Load(STR)
      |  cons_Cmd_Import(STR)
      |  cons_Cmd_Save(STR)
      |  cons_Cmd_FSave(STR)
      |  cons_Cmd_Print()
      |  cons_Cmd_Quit()
      |  cons_Cmd_FQuit()
      ;
</ga>
\end{lstlisting}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%FUNÇÕES-CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Assinatura das funções utilizadas}
Vamos agora apresentar as assinaturas das funções que foram utilizadas para nós dar suporte à implementação do nosso projecto, nesta fase.

Quando falamos das funções temos: 
\begin{lstlisting}[language=C, caption={Construtores do ficheiro de consola.}]
.h do cmd
#ifndef __CMD_LIB_H
#define __CMD_LIB_H

#include <stdlib.h>

#define CMD_PROMPT "> "

// carrega uma nova configuracao
void cmd_config(char* ficheiro);

// carrega o estado da aplicacao
void cmd_load(char* ficheiro);

// importa um CSV
void cmd_import(char* ficheiro);

// escreve o html com os dados existentes
void cmd_print();

// guarda o estado da aplicacao
void cmd_save(char* ficheiro, int force);

// sair da aplicacao
int cmd_quit();

#endif
\end{lstlisting} 
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%YACC-CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{YACC}

No ficheiro do \textit{YACC} cada produção que seja "apanhada" é chamada a função correpondente para tratar a operação que foi capturada.

\begin{lstlisting}[language=C, caption={YACC do ficheiro cmd.}]
extern int cmdlex (void);
extern void cmdlex_destroy();
%}
%union{ char* cmd_ficheiro; }
%type <cmd_ficheiro> FICHEIRO
%start Comandos
%%
Comandos : Comando '\n' Comandos
         | 
         ;
Comando : Config
        | Load
        | Import
        | Print
        | Save
        | Quit
        | {/*| error  { printf("Comando invalido2.\n%s", CMD_PROMPT); yyclearin; yyerrok; }*/}
        ;

Config : CONFIG FICHEIRO { cmd_config($2); printf(CMD_PROMPT); };
       | CONFIG

Load : LOAD FICHEIRO { cmd_load($2); printf(CMD_PROMPT); };
     | LOAD

Import : IMPORT FICHEIRO { cmd_import($2); printf(CMD_PROMPT); }
       | IMPORT
       ;

Save : SAVE FICHEIRO { cmd_save($2, 0); printf(CMD_PROMPT); }
     | FSAVE FICHEIRO { cmd_save($2, 1); printf(CMD_PROMPT); }
     | SAVE
     | FSAVE
     ;

Print : PRINT { cmd_print(); printf(CMD_PROMPT); };

Quit : QUIT  { if(cmd_quit()){
                    cmdlex_destroy();
                    YYACCEPT;
               }else{
                    printf(CMD_PROMPT);
               }}
     | FQUIT { cmdlex_destroy(); YYACCEPT; }
     ;

%%
int yyerror( char* s ){
    //fprintf(stderr, "%s", s);
    return 0;
}
\end{lstlisting} 

Para o ficheiro de CMD tinhamos que ter o Yacc a apanhar os campos relativos aos comandos, para isso temos que cada produção trata um caso especifico relativo a esse campos.


\subsection{Especificação para os Ficheiros de Resultados}
%%%%%%%%%%%%%%%%%%%%%%%%%%GRAMÁTICA-FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Gramática Especificação para os Ficheiros de Resultados}

A gramática a apresentar é a usada para o ficheiros de resultados. Assim sendo tem-se:
\begin{lstlisting}[language=C, caption={Gramática para a linguagem de especificação para os ficheiros de resultados.}]
<ga>
  
  Linhas -> cons_csv_Linhas(Linha Linhas)
          | cons_csv_Linhas_NIL()
          ;

  Linha -> cons_csv_Linha(Linha Campo)
        | cons_csv_Linha_Fim(Campo)
        ;

  Campo -> cons_csv_Campo(STR)
        | cons_csv_Campo_NIL()
        ;
 </ga>
\end{lstlisting}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%ESTRUTURA DE DADOS -FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Estrutura de Dados da Espeficicação dos Ficheiros de Resultados}

A estrutura que é gerada para o armazenamento dos campos que a gramática abstrata definiu, é divida consoante o nível em que estamos, isto é, nós começamos por ter a estrtura que vai abragir mais campos, neste caso o total de configurações, depois temos o que é um configuração e por último a estrutura que vai guardar um para uma configuração.

\begin{lstlisting}[language=C, caption={Estrutura de dados para armazenar a especificação dos ficheiros de resultados.}]

/* --- Linhas ---*/
struct sLinhas 
{ int flag;
  union {  
    struct {
        Linha s1;
        Linhas s2;
      } d1;
    struct {
      } d2;

  } u;
};

/* --- Linha ---*/
struct sLinha 
{ int flag;
  union {  
    struct {
        Linha s1;
        Campo s2;
      } d1;
    struct {
        Campo s1;
      } d2;

  } u;
};

/* --- Campo ---*/
struct sCampo 
{ int flag;
  union {  
    struct {
        char * s1;
      } d1;
    struct {
      } d2;

  } u;
};

\end{lstlisting}

\subsubsection{Assinatura das funções utilizadas}
Vamos agora apresentar as assinaturas das funções que foram utilizadas para nós dar suporte à implementação do nosso projecto, nesta fase.

Quando falamos das funções temos: 
\begin{lstlisting}[language=C, caption={Construtores do ficheiro de resultados.}]

/* -----------------------------------
 * Constructor Function Signatures
 * -----------------------------------
 */

Confs  cons_cfg_Confs( Conf a1, Confs a2);
Confs  cons_cfg_Confs_NIL();

Conf  cons_cfg_Conf_Titulo( char * a1);
Conf  cons_cfg_Conf_Nprovas( int a1);
Conf  cons_cfg_Conf_Ntop( int a1);
Conf  cons_cfg_Conf_Campos( Lcampos a1);
Conf  cons_cfg_Conf_Tempo( int a1);
Conf  cons_cfg_Conf_Chave( int a1);
Conf  cons_cfg_Conf_Nome( int a1);

Lcampos  cons_cfg_Lcampos_Lcampos( Lcampos a1, int a2);
Lcampos  cons_cfg_Lcampos_Campo( int a1);

/* -----------------------------------
 * Custom Function Signatures
 * -----------------------------------
 */

void cfg_Confs_print( Confs cfgs );
int cfg_Confs_validate( Confs cfgs );
Lcampos cfg_Lcampos_reverse( Lcampos l );

// getters
int cfg_get_Nprovas( Confs cfgs );
int cfg_get_Ntop( Confs cfgs );
int cfg_get_Tempo( Confs cfgs );
int cfg_get_Chave( Confs cfgs );
int cfg_get_Nome( Confs cfgs );
char* cfg_get_Titulo( Confs cfgs );

// obtem um array de inteiros com os campos. terminado com -1
int* cfg_get_Campos( Confs cfgs );
int cfg_get_NCampos( Confs cfgs );

// obtem um array de bytes que esta a 1 nos campos que foram seleccionados
char* cfg_Campos_seleccionado( Confs cfgs, int totalCampos );

/* -----------------------------------
 * Destructor Function Signatures
 * -----------------------------------
 */

void free_cfg_Lcampos( Lcampos campos );
void free_cfg_Conf( Conf cfg );
void free_cfg_Confs( Confs cfgs );

#endif
\end{lstlisting} 
\newpage

\subsubsection{YACC}
%%%%%%%%%%%%%%%%%%%%%%%%%%YACC-FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
No ficheiro do \textit{YACC} cada produção que seja "apanhada" é chamada a função correpondente para tratar o caso apanhado.

\begin{lstlisting}[language=C, caption={YACC do ficheiro de resultados.}]

%token str
%{
#include <stdio.h>
#include <stdlib.h>
#include "csv.lib.h"

#define YYERROR_VERBOSE

extern unsigned int csvlineno;
extern int csvlex (void);
extern void csvlex_destroy();
%}
%union{
  char * csv_str;
  
  Linhas csv_Linhas;
  Linha  csv_Linha;
  Campo  csv_Campo;

} 

%type<csv_str> str
%type<csv_Campo> Campo
%type<csv_Linhas> X Linhascsv
%type<csv_Linha> Linha
%start X

%%
X : Linhascsv '$' { $$ = $1; 
                    csvlex_destroy();
                    if( csv_Linhas_validate($$) ){
                        csv_import_csv($$);
                        YYACCEPT;
                    }else{
                        YYABORT;
                    }
                  };

Linhascsv : Linha '\n' Linhascsv {$1 = csv_Linha_reverse($1);
                                  $$ = cons_csv_Linhas ($1,$3);}
          | {$$ = cons_csv_Linhas_NIL();}
          ;

Linha : Linha ';' Campo {$$ = cons_csv_Linha ($1,$3);}
      | Campo {$$ = cons_csv_Linha_Fim ($1);}
      ;

Campo : str {$$ = cons_csv_Campo ($1);}
      | {$$ = cons_csv_Campo_NIL();}
      ;

%%
int yyerror( char* s ){
    fprintf(stderr, "Line %d: %s\n", csvlineno, s);
    return 0;
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%LEX-FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{LEX}

\begin{lstlisting}
%{
#define YY_NO_INPUT
#include <string.h>
#include "csv.lib.h"
#include "csv.tab.h"
%}
%option yylineno
%option nounput

%%
[^\n\;]+ {csvlval.csv_str = strdup(csvtext);
         return str;}
\n+     {return '\n';}
\;      {return ';';}
<<EOF>> {return '$';}


%%
int csvwrap(){
  return 1;
}
\end{lstlisting}

\newpage

\section{Anexos}

\newpage

\section{Elementos do Grupo}
\begin{figure}[h!]
\centering
\begin{subfigure}{.33\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{60}
  \caption{Bruno Ferreira  }
\end{subfigure}%
\begin{subfigure}{.33\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{107}
  \caption{Cláudia Oliveira}
\end{subfigure}%
\begin{subfigure}{.33\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{93}
  \caption{Vanessa Campos}
\end{subfigure}%
\end{figure}



\end{document}