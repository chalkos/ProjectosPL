\documentclass[11pt, a4paper, oneside]{article}

\usepackage{indentfirst}

% hifenização e outras especificações para português
\usepackage[portuguese]{babel}
\usepackage{listings}
% para ter imagens, depois define a directoria de imagens
\usepackage{graphicx}
\graphicspath{{./imagens/}}
\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{color}
 
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=C++,                   % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
numberstyle=\tiny,
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
keywordstyle=\color[rgb]{0,0,1},
basicstyle=\tiny,
commentstyle=\color[rgb]{0.133,0.545,0.133},
stringstyle=\color[rgb]{0.627,0.126,0.941},
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

% hiperligações
\usepackage{hyperref}
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black}

% checkmarks
\usepackage{tikz}
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}

% escrever acentos e coisas do género sem que o latex se desoriente
\usepackage[utf8]{inputenc}

% para ter imagens, depois define a directoria de imagens
\usepackage{graphicx}
\graphicspath{{./imagens/}}

\usepackage[labelformat=simple]{caption}
\usepackage[labelformat=empty]{subcaption}

% para ter a informação de quantas páginas tem o documento
\usepackage{lastpage}

% definir o cabeçalho e rodapé
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[L]{\small{\textbf{Gestão de Campeonatos de Orientação}}}
\fancyhead[R]{\small{Processamento de Linguagens}}

% ter enumerações alinhadas
\usepackage{enumitem}

% escrever algoritmos
\usepackage[algoruled]{algorithm2e}

% definir comandos especiais
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex} %

\newcommand{\todo}[1] {\textcolor{BrickRed}{\begin{quote}#1\end{quote}}}

%\usepackage{listings}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% inicio do documento
\begin{document}
\title{Gestão de Campeonatos de Orientação}
\date{\today\\Universidade do Minho}
\author{
  Bruno Ferreira\\
  {\small A61055}\\
  \and
  Cláudia Oliveira\\
  {\small A60987}\\
  \and
  Vanessa Campos\\
  {\small A54801}\\
}

\maketitle

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.4\linewidth]{logo}
\end{center}
\end{figure}


\begin{abstract}

  O presente trabalho foi desenvolvido no âmbito da unidade curricular de Processamento de Linguagens e tem como principal objetivo o aumento da capacidade de escrever gramáticas independentes de contexto que satisfaçam a condição de LR(), a utilização de ferramentas como o \emph{flex} e \emph{yacc} e o desenvolvimento de processadores de linguagens. De entre os vários temas, Gestão de Campeonatos de Orientação foi o tema escolhido pelo nosso grupo para este trabalho prático. Ao longo deste relatório iremos apresentar os principais aspetos do funcionamento da aplicação e explicar as estruturas de dados que foram implementadas para o desenvolvimento deste trabalho, bem como todas as decisões que foram tomadas ao longo deste projeto.

\end{abstract}
\newpage

\tableofcontents

\newpage
\section{Introdução}

A Orientação é um desporto que tem como objetivo percorrer uma determinada distância, onde o atleta tem de obrigatoriamente passar pelos pontos que estão indicados no mapa que lhe é atribuído.

Neste contexto, o foco deste projeto passa pela gestão de campeonatos de orientação onde é necessário saber a informação das provas que são efetuadas, os participantes envolvidos e os tempos que cada atleta obteve, de modo a serem obtidas as classificações necessárias.

A informação das provas é fornecida através de ficheiros CSV e é depois processada de acordo com as regras definidas num ficheiro de configurações. A pedido do utilizador, é gerado um relatório em formato HTML.

\subsection{Contextualização técnica}

\textsf{Flex} é uma ferramenta para gerar automaticamente analisadores léxicos, isto é, programas que reconhecem padrões léxicos num texto. O \textsf{flex} é uma evolução da ferramenta \textsf{lex}, mas com a caraterística de ser mais rápido que este (\textsf{Fast lex}).

\textsf{Yacc} é utilizado para sistemas operacionais \textsf{Unix}, no qual o seu principal objetivo é gerar analisadores sintáticos. No entanto, o \textsf{yacc} tem de ser utilizado em conjunto com o \textsf{lex}, pois o \textsf{yacc} não consegue ler a partir de uma entrada de dados, daí é necessário a utilização do \textsf{lex} para que este consiga gerar os tokens, que mais tarde serão usados pelo \textsf{yacc} para o processamento dos dados.

Gramática Independente de Contexto é uma gramática formal onde são definidas regras de produção da V $\rightarrow$ W onde V é um símbolo não terminal e W um conjunto de símbolos terminais ou variáveis (W no entanto também pode ser nulo).

\textsf{Gabs} é uma ferramenta que gera as estruturas de dados e respetivos construtores para permitir armazenar os dados recolhidos durante o \emph{parsing}. O \textsf{Gabs} gera estas informações a partir da especificação da gramática abstrata. Mais informações no \href{https://github.com/jcramalho/GABS---Intermediate-Representation-Generator-for-Small-Compilers/}{repositório do projeto} (https://github.com/jcramalho/ GABS-{-}-Intermediate-Representation-Generator-for-Small-Compilers/).

Gramática Abstrata é uma gramática simplificada onde apenas constam os símbolos não terminais e os símbolos terminais variáveis.

\subsection{Enunciado}

De uma maneira geral, para este trabalho pretende-se desenvolver os seguintes pontos:

\begin{itemize}
\item Especificação de uma gramática para a linguagem de comandos da consola;
\item Especificação de uma gramática para a linguagem de especificação de configurações;
\item Especificação de uma gramática para os ficheiros de resultados;
\item Desenvolver os respetivos parsers;
\item Adicionar as ações semânticas necessárias.
\end{itemize}

\newpage
\section{Desenvolvimento}

\subsection{Funcionamento do Programa}

Para compilar a aplicação deve-se correr o comando \texttt{make gco} na directoria \texttt{$<$project-root$>$/src}. A aplicação é então copiada para a pasta \texttt{$<$project-root$>$/bin}, de onde se deve iniciar a aplicação com \texttt{./gco}.

A aplicação aceita um argumento. Este argumento é o nome da primeira configuração que deve ser carregada. Se não forem fornecidos argumentos, a aplicação tentará carregar o ficheiro \texttt{default.cfg}. Caso o carregamento da configuração inicial não tenha sucesso a aplicação termina.

Depois de iniciada, a aplicação possui um ambiente de consola onde se podem usar os seguinte comandos:
\begin{description}
\item[\begin{tabular}{l}
config {[$<$ficheiro$>$]}\\
c {[$<$ficheiro$>$]}\\
\end{tabular}] \hfill \\
	Carregar um ficheiro de configuração.
	
\item[\begin{tabular}{l}
import $<$ficheiro\_csv$>$\\
i $<$ficheiro\_csv$>$\\
\end{tabular}] \hfill \\
	Carregar o ficheiro da prova em formato CSV.
	
\item[\begin{tabular}{l}
save {[$<$estado$>$]}\\
s {[$<$estado$>$]}\\
\end{tabular}] \hfill \\
	Guarda o estado da aplicação com o nome de estado especificado. Se o estado já existir o comando não tem efeito.
	
\item[\begin{tabular}{l}
save! {[$<$estado$>$]}\\
s! {[$<$estado$>$]}\\
\end{tabular}] \hfill \\
	Guarda o estado da aplicação com o nome de estado especificado, se o estado já existir é sobrescrito.
	
\item[\begin{tabular}{l}
load $<$estado$>$\\
l $<$estado$>$\\
\end{tabular}] \hfill \\
	Carregar o estado da aplicação que foi previamente guardado.
	
\item[\begin{tabular}{l}
print\\
p\\
\end{tabular}] \hfill \\
	Criar o ficheiro \texttt{index.html} com os resultados das provas em memória.
	
\item[\begin{tabular}{l}
quit\\
q\\
\end{tabular}] \hfill \\
	Termina a aplicação. Se o estado da aplicação não tiver sido guardado recentemente o comando não tem efeito.
	
\item[\begin{tabular}{l}
quit!\\
q!\\
\end{tabular}] \hfill \\
	Termina a aplicação, descartando quaisquer alterações não guardadas ao estado da aplicação.
\end{description}

\newpage
No ficheiro de configuração devem constar as seguintes informações, todas obrigatórias, uma por linha no formato \texttt{chave valor}.

\begin{description}
\item[=titulo=] \hfill \\
	O nome do campeonato.
\item[=nprovas=] \hfill \\
	O número de provas previstas para o campeonato. Ao importar um número de provas superior a este número, é mostrado um alerta.
\item[=ntop=] \hfill \\
	O número de melhores pontuações que serão consideradas para a classificação final dos atletas.
\item[=campos=] \hfill \\
	A lista de posições (com início em 1) das colunas que constarão no relatório HTML. A especificação de cada posição deve começar com \texttt{'\$'} seguido do número da posição e as várias posições devem ser separadas por \texttt{';'}\\
	Por exemplo: \texttt{"\$1;\$5;\$6"} indica que devem ser selecionadas a primeira, quinta e sexta colunas.
\item[=tempo=] \hfill \\
	Indicação da coluna onde se pode obter o tempo que o atleta demorou a concluir o percurso. Deve respeitar o mesmo formato da especificação de um campo na lista de campos, isto é, \texttt{'\$'} seguido da posição da coluna.\\
	Os tempos devem estar no formato \texttt{HH:MM:SS}. Todos os valores que não estejam neste formato são assumidos como a desclassificação do atleta (\emph{DNF} ou \emph{Did Not Finish}).
\item[=chave=] \hfill \\
	Indicação da coluna onde se pode obter um identificador único do atleta nas provas do campeonato. Deve respeitar o mesmo formato da especificação de um campo na lista de campos, isto é, \texttt{'\$'} seguido da posição da coluna.
\item[=nome=] \hfill \\
	Indicação da coluna onde se pode obter o nome do atleta. Deve respeitar o mesmo formato da especificação de um campo na lista de campos, isto é, \texttt{'\$'} seguido da posição da coluna.
\end{description}

O ficheiro CSV é um ficheiro que representa uma tabela com os resultados de uma prova, onde cada linha representa o desempenho de um atleta e cada coluna um campo. Os campos são separados por \texttt{';'}. Existe uma forte restrição na escrita dos ficheiros CSV para assegurar o bom funcionamento da aplicação: todas as linhas têm de ter um número de campos igual ao número de campos da primeira linha. Existem outras propriedades que devem ser asseguradas, por exemplo, que a coluna designada como chave realmente identifica de forma única um atleta, caso contrário as informações de vários atletas são fundidas e ignoradas dependendo da ordem em que são lidas pela aplicação.

\newpage
\subsection{Organização do Programa}

Para concretizar o projeto, foram desenvolvidos 3 \emph{parsers}:
\begin{itemize}
\item Parser de ficheiros de configurações;
\item Parser de ficheiros de comandos;
\item Parser de ficheiros de prova.
\end{itemize}

Dividimos também a aplicação por módulos. Alguns módulos contêm analisadores léxicos e sintáticos, outros são apenas conjuntos de estruturas de dados e funções que estão de algum modo relacionadas. Os módulos presentes no projeto são:
\begin{description}
\item[atl (Atleta)] \hfill \\
	Representação e manipulação dos dados de um atleta;
	
\item[cfg (Configurações)] \hfill \\
	Parser de configurações, representação interna e manipulação dos dados de configuração da aplicação;

\item[cmd (Comando)] \hfill \\
	Parser de comandos e encaminhamento das várias tarefas para os respetivos módulos;

\item[csv (CSV)] \hfill \\
	Parser de ficheiros CSV, representação interna e manipulação dos dados de uma prova;

\item[gco (Gestão de Campeonatos de Orientação)] \hfill \\
	Inicia a aplicação e trata dos preparativos antes de entrar no modo de linha de comandos;
	
\item[htm (HTML)] \hfill \\
	Escrever o ficheiro \texttt{index.html} com os resultados do campeonato;
	
\item[sav (Savestate)] \hfill \\
	Contém funções para guardar e carregar o estado da aplicação.
\end{description}

\newpage
Foi feito um esforço por manter os ficheiros organizados. Nem todos os módulos possuem ficheiros de todos os tipos, por exemplo, alguns não precisam de analisar ficheiros e por isso não têm ficheiros para uso do \emph{flex} e \emph{yacc}. Os nomes dos ficheiros seguem a seguinte organização (onde @ é o nome do módulo):

\begin{description}
\item[\begin{tabular}{l}
@.lib.h\\
@.lib.c\\
\end{tabular}] \hfill \\
	Estruturas de dados e funções para manipular os dados do módulo. Nos módulos que contêm \emph{parsers} estes ficheiros começaram por ser apenas as funções e estruturas de dados geradas pelo \emph{GABS}, sendo depois adicionadas mais funcionalidade a estes dois ficheiros;
	
\item[\begin{tabular}{l}
@.ga\\
\end{tabular}] \hfill \\
	Representação da gramática abstrata necessária para usar o \emph{GABS};
	
\item[\begin{tabular}{l}
@.y\\
\end{tabular}] \hfill \\
	Regras do analisador sintático, a serem interpretadas pelo \emph{yacc};
	
\item[\begin{tabular}{l}
@.l\\
\end{tabular}] \hfill \\
	Regras do analisador léxico, a serem interpretadas pelo \emph{flex};

\item[\begin{tabular}{l}
@.tab.h\\
@.tab.c\\
\end{tabular}] \hfill \\
	{[gerado por compilação, intermédio]} Ficheiros da análise sintática, gerados pelo \texttt{yacc} a partir do ficheiro \texttt{@.y};

\item[\begin{tabular}{l}
lex.@.c\\
\end{tabular}] \hfill \\
	{[gerado por compilação, intermédio]} Ficheiros da análise léxica, gerados pelo \texttt{flex} a partir do ficheiro \texttt{@.l};

\item[\begin{tabular}{l}
gco\\
\end{tabular}] \hfill \\
	{[gerado por compilação, binário]} Programa final que reúne as funcionalidades de todos os módulos;

\item[ ------------------ Obsoletos ------------------ ]

\item[\begin{tabular}{l}
@.main.c\\
\end{tabular}] \hfill \\
	{[obsoleto]} Ficheiro utilizado para testes numa fase inicial do projeto em que os módulos não tinham muitas dependências entre si;

\item[\begin{tabular}{l}
@.mockups.c\\
\end{tabular}] \hfill \\
	{[obsoleto]} Utilizado para criar funções cuja existência era requerida. Foram utilizados numa fase do projeto em que já existiam algumas dependências entre os vários módulos com o objetivo de permitir testar módulos individualmente;

\item[\begin{tabular}{l}
@ (excepto gco)\\
\end{tabular}] \hfill \\
	{[gerado por compilação, binário, obsoleto]} Programas que faziam análise léxica e sintática e tinham algumas ações semânticas associadas, utilizavam o ficheiro \texttt{@.main.c};

\item[\begin{tabular}{l}
@.tok.c\\
\end{tabular}] \hfill \\
	{[obsoleto]} Ficheiro utilizado para gerar o tokenizer. Utilizado para testes numa fase inicial do projeto em que os módulos não tinham muitas dependências entre si;

\item[\begin{tabular}{l}
@tok\\
\end{tabular}] \hfill \\
	{[gerado por compilação, binário, obsoleto]} Programas que apenas mostravam os tokens reconhecidos (tokenizer).
\end{description}

Os ficheiros marcados como obsoletos foram necessários ao longo do desenvolvimento da aplicação, mas não são necessários na fase final do projeto. Assim sendo deixaram de ser atualizados à medida que iam perdendo utilidade e não é assegurado o seu correto funcionamento. O objetivo da sua inclusão na fase final do projeto é apenas referir a sua utilidade.

Apresenta-se agora uma tabela onde se mostra claramente que ficheiros compõem cada módulo (excluindo itens obsoletos e obtidos por compilação):\\

\begin{table}[!h]
\caption{Ficheiros constituintes dos módulos}
\centering
\begin{tabular}{  c   c  c  c  c  c  }
	             & \texttt{@.lib.h} & \texttt{@.lib.c} & \texttt{@.ga} & \texttt{@.y} & \texttt{@.l} \\ \hline
	\texttt{atl} &    \checkmark    &    \checkmark    &               &              &              \\ \hline
	\texttt{cfg} &    \checkmark    &    \checkmark    &   \checkmark  &  \checkmark  &  \checkmark  \\ \hline
	\texttt{cmd} &    \checkmark    &    \checkmark    &               &  \checkmark  &  \checkmark  \\ \hline
	\texttt{csv} &    \checkmark    &    \checkmark    &   \checkmark  &  \checkmark  &  \checkmark  \\ \hline
	\texttt{gco} &                  &    \checkmark    &               &              &              \\ \hline
	\texttt{htm} &    \checkmark    &    \checkmark    &               &              &              \\ \hline
	\texttt{sav} &    \checkmark    &    \checkmark    &               &              &              \\ \hline
\end{tabular}
\end{table}

\newpage
\subsection{Especificação da Linguagem de Configurações da Aplicação}

\subsubsection{Gramática Abstrata}

\begin{lstlisting}[language=C, caption={Gramática abstrata utilizada pelo \emph{GABS}}]
<ga>
  Confs -> cons_cfg_Confs(Conf Confs)
        |  cons_cfg_Confs_NIL()
        ;

  Conf -> cons_cfg_Conf_Titulo(STR)
       |  cons_cfg_Conf_Nprovas(INT)
       |  cons_cfg_Conf_Ntop(INT)
       |  cons_cfg_Conf_Campos(Lcampos)
       |  cons_cfg_Conf_Tempo(INT)
       |  cons_cfg_Conf_Chave(INT)
       |  cons_cfg_Conf_Nome(INT)
       ;

  Lcampos -> cons_cfg_Lcampos_Lcampos(Lcampos INT)
          |  cons_cfg_Lcampos_Campo(INT)
          ;
</ga>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%ESTRUTURAS-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Estrutura de Dados da Especificação de Configurações}
A estrutura que é gerada para o armazenamento dos campos que a gramática abstrata definiu, é dividida consoante o nível em que se está. Assim, começa-se pela estrutura que vai abranger mais campos, que neste caso corresponde ao número total de configurações, depois pela configuração, e, por último, a estrutura que vai guardar um campo para uma configuração.

\begin{lstlisting}[language=C, caption={Estrutura de dados para armazenar as configurações.}]
struct sConfs 
{ int flag;
  union {  
    struct {
        Conf s1;
        Confs s2;
      } d1;
    struct {
      } d2;
  } u;
};
\end{lstlisting}
\newpage
\begin{lstlisting}[language=C, caption={Estrutura de dados que armazena uma configuração.}]
struct sConf 
{ int flag;
  union {  
    struct {
        char * s1;
      } d1;
    struct {
        int s1;
      } d2;
    struct {
        int s1;
      } d3;
    struct {
        Lcampos s1;
      } d4;
    struct {
        int s1;
      } d5;
  } u;
};
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Estrututura de dados que armazena os campos de uma configuração.}]
struct sLcampos 
{ int flag;
  union {  
    struct {
        Lcampos s1;
        int s2;
      } d1;
    struct {
        int s1;
      } d2;
  } u;
};
\end{lstlisting}

Verifica-se aqui que cada \textsf{struct} acima apresentada deriva de cada uma das produções que foram indicadas na gramática abstrata.
As produções que foram usadas para definir a gramática abstrata são as mesmas que foram usadas para definir o \textsf{yacc}.
\newpage

\subsubsection{Assinatura das funções utilizadas}
Aqui serão apresentadas as assinaturas das funções que foram utilizadas para dar suporte à implementação do projeto desenvolvido.

\begin{lstlisting}[language=C, caption={Construtores do ficheiro de configuração.}]
/* -----------------------------------
 * Constructor Function Signatures
 * -----------------------------------
 */

Confs  cons_cfg_Confs( Conf a1, Confs a2);
Confs  cons_cfg_Confs_NIL();

Conf  cons_cfg_Conf_Titulo( char * a1);
Conf  cons_cfg_Conf_Nprovas( int a1);
Conf  cons_cfg_Conf_Ntop( int a1);
Conf  cons_cfg_Conf_Campos( Lcampos a1);
Conf  cons_cfg_Conf_Tempo( int a1);
Conf  cons_cfg_Conf_Chave( int a1);
Conf  cons_cfg_Conf_Nome( int a1);

Lcampos  cons_cfg_Lcampos_Lcampos( Lcampos a1, int a2);
Lcampos  cons_cfg_Lcampos_Campo( int a1);
\end{lstlisting} 

Os construtores da aplicação são criados automaticamente pelo \textsf{gabs}. Esta ferramenta para além de criar as estrutura de dados, cria também todos os construtores necessários para a criação da mesma.

\begin{lstlisting}[language=C, caption={Funções do ficheiro de configuração.}]
/* -----------------------------------
 * Custom Function Signatures
 * -----------------------------------
 */
void cfg_Confs_print( Confs cfgs );
int cfg_Confs_validate( Confs cfgs );
Lcampos cfg_Lcampos_reverse( Lcampos l );

// getters
int cfg_get_Nprovas( Confs cfgs );
int cfg_get_Ntop( Confs cfgs );
int cfg_get_Tempo( Confs cfgs );
int cfg_get_Chave( Confs cfgs );
int cfg_get_Nome( Confs cfgs );
char* cfg_get_Titulo( Confs cfgs );

// obtem um array de inteiros com os campos. terminado com -1
int* cfg_get_Campos( Confs cfgs );
int cfg_get_NCampos( Confs cfgs );

// obtem um array de bytes que esta a 1 nos campos que foram selecionados
char* cfg_Campos_seleccionado( Confs cfgs, int totalCampos );
\end{lstlisting} 

Embora já estejam os construtores definidos automaticamente foi necessário criar novas funções para ser possível manusear a estrutura de dados e criar funcionalidades. Deste modo, foram criadas funções que permitem ir "buscar" algum campo específico, ou fazer operações como de validação, imprimir, entre outras.

\textbf{Nota:} Foi necessário desenvolver a função \texttt{Lcampos cfg\_Lcampos\_reverse( Lcampos l )}, uma vez que a gramática definida neste programa tem recursividade à esquerda e era necessário imprimir os valores pela ordem correta, daí a necessidade da criação desta função.
\newpage
\begin{lstlisting}[language=C, caption={Funções de libertação de memória.}]
/* -----------------------------------
 * Destructor Function Signatures
 * -----------------------------------
 */
void free_cfg_Lcampos( Lcampos campos );
void free_cfg_Conf( Conf cfg );
void free_cfg_Confs( Confs cfgs );
\end{lstlisting} 

Foram implementadas funções de libertação de memória para garantir que toda a memória, que inicialmente foi criada pelo malloc, existisse um free, garantindo assim que a aplicação não tem qualquer tipo de memory leek.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%yacc-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\textsf{Yacc}}
No ficheiro do \textsf{yacc} existe, para cada produção, que seja "apanhada", uma função correspondente.

\begin{lstlisting}[language=C, caption={Yacc do ficheiro de configuração.}]
%token TITULO NPROVAS NTOP CAMPOS TEMPO CHAVE NOME str num
%{
#include <stdio.h>
#include <stdlib.h>
#include "cfg.lib.h"

#define YYERROR_VERBOSE

extern unsigned int cfglineno;
extern int cfglex (void);
extern int gco_set_Config(Confs cfg);
extern void cfglex_destroy();
%}
%union{
    char* cfg_str;
    int cfg_num;
    
    Confs cfg_confs;
    Conf cfg_conf;
    Lcampos cfg_campos;
}
%type <cfg_str> str Titulo
%type <cfg_num> num Nprovas Ntop Tempo Campo Chave Nome
%start Z

%type <cfg_confs> Z Configuracoes
%type <cfg_conf> Configuracao
%type <cfg_campos> Lcampos Campos
%%
Z : Configuracoes '$' { $$ = $1;
                        cfglex_destroy();
                        if( gco_set_Config($$) == 0 )
                            YyaccEPT;
                        YYABORT; };

Configuracoes : Configuracao '\n' Configuracoes {$$ = cons_cfg_Confs($1,$3);}
              | { $$ = cons_cfg_Confs_NIL(); }
              ;

Configuracao : Titulo  { $$ = cons_cfg_Conf_Titulo($1); }
             | Nprovas { $$ = cons_cfg_Conf_Nprovas($1); }
             | Ntop    { $$ = cons_cfg_Conf_Ntop($1); }
             | Tempo { $$ = cons_cfg_Conf_Tempo($1); }
             | Campos  { $$ = cons_cfg_Conf_Campos($1); }
             | Chave { $$ = cons_cfg_Conf_Chave($1); }
             | Nome { $$ = cons_cfg_Conf_Nome($1); }
             ;

Titulo  : TITULO str     { $$ = $2; };
Nprovas : NPROVAS num    { $$ = $2; };
Ntop    : NTOP num       { $$ = $2; };
Campos  : CAMPOS Lcampos { $$ = cfg_Lcampos_reverse( $2 ); }
Tempo   : TEMPO '$' num  { $$ = $3; };
Chave   : CHAVE '$' num  { $$ = $3; };
Nome    : NOME '$' num   { $$ = $3; };


Lcampos : Lcampos ';' Campo { $$ = cons_cfg_Lcampos_Lcampos($1,$3); }
        | Campo             { $$ = cons_cfg_Lcampos_Campo($1); }
        ;

Campo : '$' num { $$ = $2; };

%%
int yyerror( char* s ){
    fprintf(stderr, "Line %d: %s\n", cfglineno, s);
    return 0;
}
\end{lstlisting} 

Para o ficheiro de configuração o \textsf{yacc} apanha os campos relativos à configuração do ficheiro. Cada uma das produções trata de um caso específico relativo aos campos. Assim, genericamente existe um campo e uma lista de campos, sendo necessário adiciona-lo à lista, daí ser necessário existir a seguinte função: \texttt{\$\$ = cons\_cfg\_Lcampos\_Lcampos(\$1,\$3); }

A informação que o \textsf{yacc} recebe vem do processamento que o \textsf{flex} faz do ficheiro de configuração.
Quando a informação do \textsf{flex} é recebida pelo \textsf{yacc}, este apenas tem de associar as suas produções de modo a que se incluída na estrutura correta.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%lex-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\textsf{Flex}}

\begin{lstlisting}[language=C, caption={Flex utilizado para o tratamento do ficheiro de configuração.}] 
%{
#define YY_NO_INPUT
#include <string.h>
#include "cfg.lib.h"
#include "cfg.tab.h"
%}
%option nounput
%option yylineno
%x ler_string
%x ler_numero
%x ler_tempo
%x campos
%%
"=titulo="  {BEGIN ler_string; return TITULO;}
"=nprovas=" {BEGIN ler_numero; return NPROVAS;}
"=ntop="    {BEGIN ler_numero; return NTOP;}
"=campos="  {BEGIN campos;     return CAMPOS;}
"=tempo="   {BEGIN ler_numero; return TEMPO;}
"=chave="   {BEGIN ler_numero; return CHAVE;}
"=nome="    {BEGIN ler_numero; return NOME;}

<ler_string>[^\n]+ {if(*cfgtext == ' ')
                        cfglval.cfg_str = strdup(cfgtext+1);
                    else
                        cfglval.cfg_str = strdup(cfgtext);
                    BEGIN 0;
                    return str;}
<ler_numero>\$     return '$';
<ler_numero>[0-9]+ {cfglval.cfg_num = atoi(cfgtext);
                    BEGIN 0;
                    return num;}

<campos>[0-9]+ { cfglval.cfg_num = atoi(cfgtext);
                 return num;}
<campos>\$     { return '$'; }
<campos>\;     { return ';'; }
<campos>\n     { BEGIN 0; return '\n'; }

<*><<EOF>>  return '$';

[\n]+       return '\n';

<*>[ \t] ;
<*>.     { /*printf("flex: %c (%d)\n", *cfgtext, *cfgtext);*/ }

%%

int cfgwrap(){
    return 1;
}
\end{lstlisting}

A informação que o ficheiro \textsf{flex} recebe é proveniente do ficheiro de configuração.
Depois de se reconhecer os campos, estes são passados do \textsf{flex} para o \textsf{yacc} através da estrutura que é interna no \textsf{yacc}.
Por exemplo, quando se utiliza a função \texttt{cfglval.cfg\_str}, significa que se está a passar (neste caso) uma string ao campo cfg\_str da union, onde posteriormente o \textsf{yacc} irá adiciona-lo à sua estrutura.
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Especificação para a Linguagem de Comandos da Consola}
A aplicação desenvolvida possui um ambiente de consola com alguns comandos básicos:
\begin{itemize}
\item \textbf{Carregar configuração}: o sistema inicializa-se sempre com esta operação. Esta operação está sempre disponível para ser possível alterar a configuração.
\item \textbf{Carregar base de dados}: o sistema carrega para memória o estado de um torneio previamente gravado.
\item \textbf{Carregar resultado de prova}: o sistema carrega e processa um ficheiro CSV. Como resultado desta operação produz um ficheiro HTML com a pontuação de cada atleta, ordenado por ordem descente de pontos.
\item \textbf{Calcular ranking}: em qualquer momento poderá ser invocada esta operação à qual o sistema responder com uma listagem em HTML do ranking.
\item \textbf{Gravar base de dados}: o sistema guarda em memória o estado da aplicação.
\item \textbf{Imprimir}: que apresenta a informação através de uma página HTML.
\item \textbf{Save}: que guarda o estado atual do sistema.
\item \textbf{Sair}: o sistema termina a aplicação, se o estado atual não tiver sido previamente gravado deverá lançar um atleta e pedir configuração para prosseguir.
\end{itemize}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%GRAMÁTICA-CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Especificação para a Linguagem de Comandos da Consola}

Esta gramática é definida depois de se ter analisado as produções que se podem ter quando estamos a tratar os comandos.

%%%%%%%%%%%%%%%%%%%%%%%%%%FUNÇÕES-CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Assinatura das funções utilizadas}
As assinaturas das funções que foram utilizadas para dar suporte à implementação do projeto, nesta fase, foram as seguintes:

\begin{lstlisting}[language=C, caption={Construtores do ficheiro de consola.}]
.h do cmd
#ifndef __CMD_LIB_H
#define __CMD_LIB_H

#include <stdlib.h>

#define CMD_PROMPT "> "

// carrega uma nova configuracao
void cmd_config(char* ficheiro);

// carrega o estado da aplicacao
void cmd_load(char* ficheiro);

// importa um CSV
void cmd_import(char* ficheiro);

// escreve o html com os dados existentes
void cmd_print();

// guarda o estado da aplicacao
void cmd_save(char* ficheiro, int force);

// sair da aplicacao
int cmd_quit();

#endif
\end{lstlisting} 

Neste caso é importante referir que quando são executadas funções \texttt{void cmd\_config(char* ficheiro)} e \texttt{void cmd\_import(char* ficheiro);} estas recebem o parser do ficheiro que lhe está associado. Se se tiver o cmd\_config o parser que será invocado será aquele que é responsável pelo ficheiro de configuração. O cmd\_import "chama" o parser que é responsável pelo ficheiro CSV.

A função \texttt{void cmd\_print();} é responsável por invocar a função que vai dar origem à página HTML pretendida.
%%%%%%%%%%%%%%%%%%%%%%%%%%yacc-CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\textsf{Yacc}}

No ficheiro do \textsf{yacc} cada produção que seja "apanhada" é chamada à função correspondente para tratar da operação que foi capturada.

\begin{lstlisting}[language=C, caption={Yacc do ficheiro cmd.}]
extern int cmdlex (void);
extern void cmdlex_destroy();
%}
%union{ char* cmd_ficheiro; }
%type <cmd_ficheiro> FICHEIRO
%start Comandos
%%
Comandos : Comando '\n' Comandos
         | 
         ;
Comando : Config
        | Load
        | Import
        | Print
        | Save
        | Quit
        | {/*| error  { printf("Comando invalido2.\n%s", CMD_PROMPT); yyclearin; yyerrok; }*/}
        ;

Config : CONFIG FICHEIRO { cmd_config($2); printf(CMD_PROMPT); };
       | CONFIG

Load : LOAD FICHEIRO { cmd_load($2); printf(CMD_PROMPT); };
     | LOAD

Import : IMPORT FICHEIRO { cmd_import($2); printf(CMD_PROMPT); }
       | IMPORT
       ;

Save : SAVE FICHEIRO { cmd_save($2, 0); printf(CMD_PROMPT); }
     | FSAVE FICHEIRO { cmd_save($2, 1); printf(CMD_PROMPT); }
     | SAVE
     | FSAVE
     ;

Print : PRINT { cmd_print(); printf(CMD_PROMPT); };

Quit : QUIT  { if(cmd_quit()){
                    cmdlex_destroy();
                    YyaccEPT;
               }else{
                    printf(CMD_PROMPT);
               }}
     | FQUIT { cmdlex_destroy(); YyaccEPT; }
     ;

%%
int yyerror( char* s ){
    //fprintf(stderr, "%s", s);
    return 0;
}
\end{lstlisting} 

Para além do ficheiro \textsf{yacc} criado para a especificação do ficheiro de configurações, foi necessário criar outro ficheiro \textsf{yacc} para a fazer a especificação do cmd. Assim, por exemplo, no caso de ser "apanhado" o \textsf{PRINT} é chamada a função \texttt{cmd\_print}, que vai imprimir a informação relativa aos jogadores para uma página \textsf{HTML}.

\subsubsection{\textsf{Flex}}

\begin{lstlisting}[language=C, caption={Flex do ficheiro cmd.}]
%{
#define YY_NO_INPUT
#include <string.h>
#include "cmd.tab.h"
#include "cmd.lib.h"
%}
%option nounput
%x ficheiro
%%
"config " {BEGIN ficheiro; return CONFIG;}
"c "      {BEGIN ficheiro; return CONFIG;}

"load " {BEGIN ficheiro; return LOAD;}
"l "    {BEGIN ficheiro; return LOAD;}

"import " {BEGIN ficheiro; return IMPORT;}
"i "      {BEGIN ficheiro; return IMPORT;}

"print"  return PRINT;
"p"      return PRINT;

"save! " {BEGIN ficheiro; return FSAVE;}
"s! "    {BEGIN ficheiro; return FSAVE;}
"save "  {BEGIN ficheiro; return SAVE; }
"s "     {BEGIN ficheiro; return SAVE; }

"quit"   return QUIT;
"q"      return QUIT;
"quit!" return FQUIT;
"q!"    return FQUIT;

<<EOF>>  return FQUIT;

[\n]+    { return '\n'; }

<ficheiro>[^\n]+ { /* se houver erros, tentar um duplicate aqui */
                   //cmdlval.cmd_ficheiro = strdup(cmdtext);
                   cmdlval.cmd_ficheiro = cmdtext;
                   BEGIN 0;
                   return FICHEIRO;
                 }
<ficheiro>[\n]    { BEGIN 0;
                    printf("Comando invalido6.\n%s", CMD_PROMPT);
                    return '\n'; }

 /** capturar comandos invalidos especiais **/
[clis]\n          { printf("Comando invalido1.\n%s", CMD_PROMPT); }
[^clipsq\n][^\n]* { printf("Comando invalido2.\n%s", CMD_PROMPT); }
"q"[^\n]+         { printf("Comando invalido3.\n%s", CMD_PROMPT); }
"p"[^\n]+         { printf("Comando invalido4.\n%s", CMD_PROMPT); }
"config"[^ ]      { printf("Comando invalido5.\n%s", CMD_PROMPT); }

. ;

%%

void cmd_lex_push( FILE* sav_file_import ){
    cmdpush_buffer_state(cmd_create_buffer(sav_file_import, YY_BUF_SIZE));
}

void cmd_lex_pop(){
    yypop_buffer_state();
}

int cmdwrap(){
    return 1;
}
\end{lstlisting}

O \textsf{flex} neste caso está associado ao input que é produzido pelo utilizador, isto é, no caso do cmd significa que não estamos a trabalhar com a nossa própria consola.

Devido ao facto de termos a nossa própria consola isso implica termos o parsing que reconhece os comandos que estão a ser introduzidos, para depois esses comandos serem passados ao \textsf{yacc}, que vai determinar que função é desencadeada como esse comando.

\subsection{Especificação para os Ficheiros de Resultados}
%%%%%%%%%%%%%%%%%%%%%%%%%%GRAMÁTICA-FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Gramática Especificação para os Ficheiros de Resultados}

A gramática abstrata que se segue vai ser usada para gerar a estrutura de representação intermédia para o ficheiro de resultados.

\begin{lstlisting}[language=C, caption={Gramática para a linguagem de especificação para os ficheiros de resultados.}]
<ga>
  
  Linhas -> cons_csv_Linhas(Linha Linhas)
          | cons_csv_Linhas_NIL()
          ;

  Linha -> cons_csv_Linha(Linha Campo)
        | cons_csv_Linha_Fim(Campo)
        ;

  Campo -> cons_csv_Campo(STR)
        | cons_csv_Campo_NIL()
        ;
 </ga>
\end{lstlisting}

As produções que se podem encontrar na gramática abstrata são provenientes da definição de produções a que consideramos importantes para tratar a informação que pode ser encontrada num ficheiro de resultados.

%%%%%%%%%%%%%%%%%%%%%%%%%%ESTRUTURA DE DADOS -FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Estrutura de Dados da Especificação dos Ficheiros de Resultados}

A estrutura que é gerada para o armazenamento dos campos que a gramática abstrata definiu, é dividida consoante o nível em que estamos. Assim, se começarmos por ter a estrutura que vai abranger mais campos, que neste caso, corresponde ao total de linhas que constituem o ficheiro, significa que depois teremos o que é uma linha e por último a estrutura que vai guardar um campo.

\begin{lstlisting}[language=C, caption={Estrutura de dados para armazenar a especificação dos ficheiros de resultados.}]

/* --- Linhas ---*/
struct sLinhas 
{ int flag;
  union {  
    struct {
        Linha s1;
        Linhas s2;
      } d1;
    struct {
      } d2;
  } u;
};

/* --- Linha ---*/
struct sLinha 
{ int flag;
  union {  
    struct {
        Linha s1;
        Campo s2;
      } d1;
    struct {
        Campo s1;
      } d2;
  } u;
};

/* --- Campo ---*/
struct sCampo 
{ int flag;
  union {  
    struct {
        char * s1;
      } d1;
    struct {
      } d2;
  } u;
};

\end{lstlisting}

\subsubsection{Assinatura das funções utilizadas}
Nesta secção serão apresentadas as assinaturas das funções que foram utilizadas para dar suporte à implementação do projeto.

\begin{lstlisting}[language=C, caption={Construtores do ficheiro de resultados.}]

/* -----------------------------------
 * Constructor Function Signatures
 * -----------------------------------
 */

Linhas  cons_csv_Linhas( Linha a1, Linhas a2);
Linhas  cons_csv_Linhas_NIL();

Linha  cons_csv_Linha( Linha a1, Campo a2);
Linha  cons_csv_Linha_Fim( Campo a1);

Campo  cons_csv_Campo( char * a1);
Campo  cons_csv_Campo_NIL();


/* -----------------------------------
 * Custom Function Signatures
 * -----------------------------------
 */
void csv_print( Linhas csv );
Linha csv_Linha_reverse( Linha l );
int csv_Linhas_validate (Linhas lcsv);

void csv_import_csv( Linhas dados );
int csv_tempo_to_int(char* str);

// indice_campo comeca em 1
char* csv_get_campo(Linha campos, int indice_campo);

/* -----------------------------------
 * Destructor Function Signatures
 * -----------------------------------
 */

void csv_free_ListaCSV(Lcsv elem);
void free_csv_Campo (Campo cmp);
void free_csv_Linha (Linha l);
void free_csv_Linhas (Linhas lcsv);

\end{lstlisting} 

Nesta secção são apresentadas as assinaturas das funções que são usadas, tanto para fazer a inicialização das estrutura de dados (criadas pelo \textsf{gabs}), quer como as funções que foram necessárias definir, de modo a ser possível efetuar operações sobre as mesmas.

Para além das funções que são responsáveis por fazer a libertação de toda a memória que foi utilizada, temos a função \texttt{Linha csv\_Linha\_reverse( Linha l );} que é utilizada para imprimir a forma como os campos foram lidos. Esta função é necessária devido ao facto de se ter definido uma gramática com recursividade à esquerda.

\newpage

\subsubsection{\textsf{Yacc}}
%%%%%%%%%%%%%%%%%%%%%%%%%%yacc-FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
No ficheiro do \textsf{yacc} cada produção que seja "apanhada" é sempre chamada a função correspondente para tratar o caso que foi apanhado.

\begin{lstlisting}[language=C, caption={Yacc do ficheiro de resultados.}]

%token str
%{
#include <stdio.h>
#include <stdlib.h>
#include "csv.lib.h"

#define YYERROR_VERBOSE

extern unsigned int csvlineno;
extern int csvlex (void);
extern void csvlex_destroy();
%}
%union{
  char * csv_str;
  
  Linhas csv_Linhas;
  Linha  csv_Linha;
  Campo  csv_Campo;
} 

%type<csv_str> str
%type<csv_Campo> Campo
%type<csv_Linhas> X Linhascsv
%type<csv_Linha> Linha
%start X

%%
X : Linhascsv '$' { $$ = $1; 
                    csvlex_destroy();
                    if( csv_Linhas_validate($$) ){
                        csv_import_csv($$);
                        YyaccEPT;
                    }else{
                        YYABORT;
                    }
                  };

Linhascsv : Linha '\n' Linhascsv {$1 = csv_Linha_reverse($1);
                                  $$ = cons_csv_Linhas ($1,$3);}
          | {$$ = cons_csv_Linhas_NIL();}
          ;

Linha : Linha ';' Campo {$$ = cons_csv_Linha ($1,$3);}
      | Campo {$$ = cons_csv_Linha_Fim ($1);}
      ;

Campo : str {$$ = cons_csv_Campo ($1);}
      | {$$ = cons_csv_Campo_NIL();}
      ;

%%
int yyerror( char* s ){
    fprintf(stderr, "Line %d: %s\n", csvlineno, s);
    return 0;
}
\end{lstlisting}

A informação que o \textsf{yacc} recebe vem do processamento que o \textsf{flex} faz do ficheiro de configuração que é passado ao \textsf{flex}.
Quando a informação do \textsf{flex} é recebida pelo \textsf{yacc}, este apenas tem de a associar a uma das suas produções de modo a ser incluída na estrutura correta.
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%lex-FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\textsf{Flex}}

\begin{lstlisting}
%{
#define YY_NO_INPUT
#include <string.h>
#include "csv.lib.h"
#include "csv.tab.h"
%}
%option yylineno
%option nounput

%%
[^\n\;]+ {csvlval.csv_str = strdup(csvtext);
         return str;}
\n+     {return '\n';}
\;      {return ';';}
<<EOF>> {return '$';}

%%
int csvwrap(){
  return 1;
}
\end{lstlisting}

O \textsf{flex} relativo ao parsing do fihceiro CSV é relativamente simples, isto deve-se ao facto de se ter definido que todos os campos do ficheiro são strings, assim sendo o único tratamento que é necessário fazer aqui e o de ver onde acaba cada string, o tratamento dos \\n, a forma de separação de cada campo e por fim o EOF.

Com esta implementação o \textsf{yacc} é responsável por decidir o modo como se irá tratar cada campo que recebe do \textsf{flex}.
 
\newpage
\subsection{Tratamento da Informação do Atleta}

Um dos requisitos necessários para o desenvolvimento da plataforma era o cálculo da pontuação dos atletas. 

Uma vez que existem vários atletas foi necessário a criação de uma estrutura que nos permitisse guardar a informação de cada uma dos atletas que participam no Campeonato Orientação.

Essa estrutura é então composta por:
\begin{itemize}
\item \textsf{ID}: identificador de atleta;
\item \textsf{nome}: nome do atleta;
\item \textsf{score}: lista de ponto obtidos em cada prova;
\item \textsf{tempo\_ultima\_prova}: tempo que o atleta obteve na última prova decorrida.
\end{itemize}

Para além de termos a informação do atleta foi necessário implementar também uma estrutura que permitisse guardar todos os atletas que participam numa prova.

Assim sendo as estruturas implementadas foram as seguintes:

\begin{lstlisting}[language=C, caption={Estrutura de um atleta.}]
struct sLInt {
    LInt proximo;
    int num;};

struct sAtletas{
    Atletas proximo;
    Atleta atleta;};

struct sAtleta{
    char* ID;
    char* nome;
    LInt scores;
    int tempo_ultima_prova;};
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Assinatura das funções.}]
Atleta atl_novo_atleta(char* id, char* nome);
void atl_add_score(Atleta atleta, int score);
int atl_get_score(Atleta atleta, int nTop);

Atletas atl_ordenar_por_Score(Atletas atletas);
Atletas atl_insere_por_ID(Atletas atletas, Atleta atleta);
Atletas atl_insere_por_Score(Atletas atletas, Atleta atleta);

void atl_print(Atletas atletas);
void atl_free_Atletas(Atletas atletas);

// versao que nao liberta memoria dos atletas em si (apenas da lista)
// usado para libertar a lista ordenada por score
void atl_free_AtletasList(Atletas atletas);
void atl_free_Atleta(Atleta atleta);
void atl_free_Scores(LInt scores);

/******************
 * Ler dados dos atletas a partir do csv
 * ***************/

Atletas atl_ler_csv( Confs cfg, Linhas csv, Atletas atletas );
Atletas atl_ler_tempos( Confs cfg, Linhas csv, Atletas atletas );
#endif
\end{lstlisting}

O tratamento desta informação serve para se poder analisar e processar os rankings das pontuações dos atletas. Deste modo, um dos requisitos necessários para processar foi os tempos obtidos por cada jogador de forma, a que mais tarde, fosse possível criar no HTML dos rankings de provas, atletas, etc.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%HTML%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{HTML}

Um dos resultados finais deste projeto é gerar uma página HTML que permita evidenciar o ranking das provas e também é mais uma forma de apresentação do resultados obtidos.

\begin{lstlisting}[language=C, caption={Assinatura das funções.}]
void htm_print_indice();
void htm_print_provas();
void htm_print_resultados();
int htm_begin();
void htm_end();
\end{lstlisting}

Como a criação de um ficheiro HTML era necessário ter um cuidado especial e foi preciso definir o HTMl por partes.
Assim, a apresentação do HTML parte por ter um índice para os rankings que poderá ser visível ao longo da página, seguindo, então, pelos respetivos rankings dos atletas no campeonato.

\newpage
\section{Conclusão}

Após concluir todo o desenvolvimento deste segundo projeto, de Processamento de Linguagens, é fácil fazer um balanço de todo este percurso realizado. Para além de ter sido um desafio implementar um programa de processamento de Gestão de Campeonatos de Orientação, que se aplica ao contexto da vida real, foi também aliciante concluir o trabalho e todas as etapas que foram propostas.
Ao longo do desenvolvimento do projeto o grupo desenvolveu competências em diversas ferramentas como \textsf{C}, HTML, \textsf{flex}, \textsf{yacc}, gramáticas independentes do contexto, que serão uma mais valia para o mercado de trabalho e para a vida profissional. 


\newpage
\section{Anexos}

\subsection{Makefile}

\begin{lstlisting}[language=C, caption={Makefile}]
.PHONY: clean

GDB=-Wall -g

#----------------\
#  Tokenizers    \
#----------------\

cmdtok : cmd.tok.c lex.cmd.o cmd.tab.o cmd.lib.o cmd.mockups.o
	gcc $(GDB) -o $@ $^ -ll

cfgtok : cfg.tok.c lex.cfg.o cfg.tab.o cfg.lib.o
	gcc $(GDB) -o $@ $^ -ll

csvtok : csv.tok.c lex.csv.o csv.tab.o csv.lib.o
	gcc $(GDB) -o $@ $^ -ll

#----------------\
#  Gco           \
#----------------\

gco : gco.lib.c sav.lib.o htm.lib.o atl.lib.o cfg.lib.o lex.cfg.o cfg.tab.o cmd.lib.o lex.cmd.o cmd.tab.o csv.lib.o lex.csv.o csv.tab.o
	gcc $(GDB) -o $@ $^
	cp gco ../bin/gco

htm.lib.o : htm.lib.c htm.lib.h cfg.lib.h csv.lib.h
	gcc $(GDB) -c htm.lib.c

atl.lib.o : atl.lib.c atl.lib.h cfg.lib.h csv.lib.h
	gcc $(GDB) -c atl.lib.c

sav.lib.o : sav.lib.c sav.lib.h
	gcc $(GDB) -c sav.lib.c

#----------------\
#  Cfg           \
#----------------\

cfg : cfg.main.c cfg.lib.o lex.cfg.o cfg.tab.o
	gcc $(GDB) -o $@ $^ -ll

cfg.lib.o : cfg.lib.c cfg.lib.h
	gcc $(GDB) -c cfg.lib.c

cfg.tab.o : cfg.tab.h cfg.tab.c
	gcc $(GDB) -c cfg.tab.c

lex.cfg.o : lex.cfg.c cfg.tab.h cfg.lib.o
	gcc $(GDB) -c lex.cfg.c -ll

cfg.tab.c cfg.tab.h : cfg.y cfg.lib.o
	yacc -d -pcfg -bcfg cfg.y

lex.cfg.c : cfg.l
	flex -Pcfg cfg.l

#----------------\
#  Cmd           \
#----------------\

cmd : cmd.main.c cmd.lib.o lex.cmd.o cmd.tab.o cmd.mockups.o
	gcc $(GDB) -o $@ $^ -ll

cmd.mockups.o : cmd.mockups.c cmd.mockups.h
	gcc $(GDB) -c cmd.mockups.c

cmd.lib.o : cmd.lib.c cmd.lib.h
	gcc $(GDB) -c cmd.lib.c

cmd.tab.o : cmd.tab.h cmd.tab.c
	gcc $(GDB) -c cmd.tab.c

lex.cmd.o : lex.cmd.c cmd.tab.h
	gcc $(GDB) -c lex.cmd.c -ll

cmd.tab.c cmd.tab.h : cmd.y cmd.lib.h
	yacc -d -pcmd -bcmd cmd.y

lex.cmd.c : cmd.l
	flex -Pcmd cmd.l


#----------------\
#  CSV           \
#----------------\

csv : csv.main.c csv.lib.o lex.csv.o csv.tab.o
	gcc $(GDB) -o $@ $^ -ll

csv.lib.o : csv.lib.c csv.lib.h
	gcc $(GDB) -c csv.lib.c

csv.tab.o : csv.tab.h csv.tab.c
	gcc $(GDB) -c csv.tab.c

lex.csv.o : lex.csv.c csv.tab.h
	gcc $(GDB) -c lex.csv.c -ll

csv.tab.c csv.tab.h : csv.y csv.lib.h
	yacc -d -pcsv -bcsv csv.y

lex.csv.c : csv.l
	flex -Pcsv csv.l
#----------------\
#  Extras        \
#----------------\

clean :
	$(RM) gabs
	$(RM) gco
	$(RM) cmd
	$(RM) cfg
	$(RM) csv
	$(RM) *.o
	$(RM) *.tab.[ch]
	$(RM) lex.*.c
	$(RM) *tok

gabs:
	cd ./../gabs/ && $(MAKE) gabs && mv ./gabs ./../src/gabs

\end{lstlisting}
\newpage

\section{Elementos do Grupo}
\begin{figure}[h!]
\centering
\begin{subfigure}{.33\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{60}
  \caption{Bruno Ferreira  }
\end{subfigure}%
\begin{subfigure}{.33\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{107}
  \caption{Cláudia Oliveira}
\end{subfigure}%
\begin{subfigure}{.33\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{93}
  \caption{Vanessa Campos}
\end{subfigure}%
\end{figure}



\end{document}