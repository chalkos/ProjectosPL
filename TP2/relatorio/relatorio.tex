\documentclass[11pt, a4paper, oneside]{article}

\usepackage{indentfirst}

% hifenização e outras especificações para português
\usepackage[portuguese]{babel}
\usepackage{listings}
% para ter imagens, depois define a directoria de imagens
\usepackage{graphicx}
\graphicspath{{./imagens/}}
\usepackage[utf8]{inputenc}    

\usepackage{listings}
\usepackage{color}
 
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
numberstyle=\tiny,
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
keywordstyle=\color[rgb]{0,0,1},
basicstyle=\tiny,
commentstyle=\color[rgb]{0.133,0.545,0.133},
stringstyle=\color[rgb]{0.627,0.126,0.941},
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

% hiperligações
\usepackage{hyperref}
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black}

% escrever acentos e coisas do género sem que o latex se desoriente
\usepackage[utf8]{inputenc}

% para ter imagens, depois define a directoria de imagens
\usepackage{graphicx}
\graphicspath{{./imagens/}}

\usepackage[labelformat=simple]{caption}
\usepackage[labelformat=empty]{subcaption}

% para ter a informação de quantas páginas tem o documento
\usepackage{lastpage}

% definir o cabeçalho e rodapé
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[L]{\small{\textbf{Gestão de Campeonatos de Orientação}}}
\fancyhead[R]{\small{Processamento de Linguagens}}

% ter enumerações alinhadas
\usepackage{enumitem}

% escrever algoritmos
\usepackage[algoruled]{algorithm2e}

% definir comandos especiais
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex} %

\newcommand{\todo}[1] {\textcolor{BrickRed}{\begin{quote}#1\end{quote}}}

%\usepackage{listings}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% inicio do documento
\begin{document}
\title{Gestão de Campeonatos de Orientação}
\date{\today\\Universidade do Minho}
\author{
  Bruno Ferreira\\
  {\small A61055}\\
  \and
  Cláudia Oliveira\\
  {\small A60987}\\
  \and
  Vanessa Campos\\
  {\small A54801}\\
}

\maketitle

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.4\linewidth]{logo}
\end{center}
\end{figure}


\begin{abstract}

  O presente trabalho foi desenvolvido no âmbito da unidade curricular de Processamento de Linguagens e tem como principal objetivo o aumento da experiência na linguagem imperativa \textsf{C}, a capacidade de escrever gramáticas independentes de contexto que satisfaçam a condição de LR(), a utilização de compiladores como o \textsf{lex}/\textsf{yacc} e o desenvolvimento de processadores de linguagem. De entre os variados temas, Gestão de Campeonatos de Orientação foi o tema escolhido pelo nosso grupo, para o desenvolvimento deste segundo trabalho prático. Ao longo deste relatório iremos explicar as estruturas de dados que foram implementadas para o desenvolvimento deste trabalho, bem como todas as decisões que foram tomadas ao longo deste projeto. 

\end{abstract}
\newpage

\tableofcontents

\newpage
\section{Introdução}

A Orientação é um desporto que tem como objetivo percorrer uma determinada distância, onde o atleta tem de obrigatoriamente passar pelos pontos que estão indicados no mapa que lhe é atribuído.

Neste contexto, o foco deste projeto passa pela gestão de campeonatos de orientação onde é necessário saber a informação das provas que são efetuadas, os participantes envolvidos e os tempos que cada atleta obteve, de modo a serem obtidas as classificações necessárias.

Outro objetivo principal deste projeto é a leitura de ficheiros, estes têm uma configuração definida pelo ficheiro de configuração. O ficheiro CSV contém a informação dos jogadores, esta informação será necessária para gerar a página HTML final com a informação tratada.

Para a implementação foi necessário a construção de gramáticas independentes de contexto, implementação de parsers para cada ficheiro. A utilização do \textsf{lex} e \textsf{yacc} foi necessária para retirar a informação relevante.


\newpage
\section{Desenvolvimento}

\subsection{Contextualização do Problema}

\textsf{Flex} é uma ferramenta para gerar automaticamente analisadores léxicos, isto é, programas que reconhecem padrões léxicos num texto. O \textsf{flex} é uma evolução da ferramenta \textsf{lex}, mas com a caraterística de ser mais rápido que este (\textsf{Fast lex}).

\textsf{Yacc} é utilizado para sistemas operacionais \textsf{Unix}, no qual o seu principal objetivo é gerar analisadores sintáticos. No entanto, o \textsf{yacc} tem de ser utilizado em conjunto com o \textsf{lex}, pois o \textsf{yacc} não consegue ler a partir de uma entrada de dados, daí é necessário a utilização do \textsf{lex} para que este consiga gerar os tokens, que mais tarde serão usados pelo \textsf{yacc} para o processamento dos dados.

Gramática Independente de Contexto é uma gramática formal onde são definidas regras de produção da V $\rightarrow$ W onde V é um símbolo não terminal e W um conjunto de símbolos terminais ou variáveis (W no entanto também pode ser nulo).

\subsection{Gestão de Campeonatos de Orientação}

Neste segundo trabalho de Processamento de Linguagens foi proposto a seleção de um projeto entre vários propostos. Após uma análise, e chegada a uma concordância, o grupo optou por escolher o tema de Gestão de Campeonato de Orientação.

Este enunciado exige que sejam feitas várias operações que ocorrem em simultâneo, e por isso existem vários ficheiros, como:
\begin{itemize}
\item Ficheiro de Resultados: ficheiro CSV, onde são guardados os resultados obtidos em cada prova.

\item Ficheiro de Configuração: ficheiro que vai definir o processamento a realizar, isto é quais as provas e os campos que vão ser tratados.
\end{itemize}

\subsection{Enunciado}

De uma maneira geral, para este trabalho pretende-se desenvolver os seguintes pontos:

\begin{itemize}
\item Especificação de uma gramática para a linguagem de comandos da consola;
\item Especificação de uma gramática para a linguagem de especificação de configurações;
\item Especificação de uma gramática para os ficheiros de resultados;
\item Desenvolver os respetivos parsers;
\item Adicionar as ações semânticas necessárias.
\end{itemize}

\subsection{Descrição do Problema}

A utilização do \textsf{flex}, \textsf{yacc} e gramáticas independentes de contexto era necessária para o desenvolvimento da aplicação de forma a permitir o tratamento de ficheiros específicos e para gerar o HTML, como os resultados pretendidos.

No entanto, existem outros requisitos que permitem o bom funcionamento da aplicação. A aplicação deve possuir um ambiente de consola e implementar os seguintes comandos:
\begin{itemize}
\item \textbf{Carregar configuração}: permite carregar o ficheiro de configuração;
\item \textbf{Carregar base de dados}: carregar um ficheiro de dados previamente guardado;
\item \textbf{Carregar resultado de prova}: carregar o ficheiro de resultados;
\item \textbf{Calcular Ranking}: permite calcular o ranking de pontuação dos atletas;
\item \textbf{Gravar base de dados}: guardar a informação que existem na memória num ficheiro;
\item \textbf{Sair}: termina a aplicação.
\end{itemize}

É a partir daqui que os ficheiro de resultados e o de configuração são lidos e só depois as operações são executadas. 

Antes de ser criado o HTML a aplicação tem de ser configurada. Para isso a informação é lida de um ficheiro de configuração onde estão definidos os campos seguintes:
\begin{itemize}
\item \textbf{Titulo}: título da prova em causa;
\item \textbf{nporvas}: nº de provas a realizar;
\item \textbf{N}: indicados do topN;
\item \textbf{campos}: ordem dos campos quando no CSV;
\item \textbf{score}: pontuação obtida.
\end{itemize}

\newpage

\section{Desenvolvimento do Programa}
Um dos pressupostos da implementação deste projeto é o tratamento de diferentes tipos de informação, foi decidido estruturar-se o projeto consoante as funções que cada ficheiro implica.
[INSERIR IMAGEM DOS FICHEIROS]

O desenvolvimento deste projeto passa assim por desenvolver três gramáticas independentes de contexto distintas: 
\begin{itemize}
\item Gramática para a linguagem de configurações;
\item Gramática para a linguagem de comandos da consola; 
\item Grámatica para ficheiros de resultados. 
\end{itemize}

Para a criação das estruturas de dados foi usada a ferramenta \textsf{gabs}, disponibilizada pelo professor, que cria a estrutura e os seus construtores, quando executada com uma gramática abstrata como argumento.

De modo a utiliza-se esta ferramenta era necessário, primeiramente, a criação de uma gramática abstrata. Por isso, uma das primeiras etapas deste projeto foi desenvolver a especificação de cada uma gramáticas independentes do contexto, acima referidas. 

Em cada uma das subsecções seguintes, será apresentada cada uma das gramáticas desenvolvidas, a estrutura de dados implementada, as assinaturas das funções em \textsf{C} e os seus construtores.

\subsection{Especificação da Linguagem de Configurações da Aplicação}

O ficheiro de configurações define o processamento a realizar: campos a extrair para o resultado final da aplicação, o número de provas que pontuam, o número de melhores resultados que serão contabilizados para a classificação, os campos que irão aparecer na página de resultado.
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%GRAMÁTICA-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Gramática para a Linguagem de Especificação de Configurações}

A gramática a apresentar é a usada para especificar o ficheiro de configuração. Assim sendo tem-se a seguinte gramática:

\begin{lstlisting}[language=C, caption={Gramática para a linguagem de especificação de configurações.}]
<ga>
  Confs -> cons_cfg_Confs(Conf Confs)
        |  cons_cfg_Confs_NIL()
        ;

  Conf -> cons_cfg_Conf_Titulo(STR)
       |  cons_cfg_Conf_Nprovas(INT)
       |  cons_cfg_Conf_Ntop(INT)
       |  cons_cfg_Conf_Campos(Lcampos)
       |  cons_cfg_Conf_Tempo(INT)
       |  cons_cfg_Conf_Chave(INT)
       |  cons_cfg_Conf_Nome(INT)
       ;

  Lcampos -> cons_cfg_Lcampos_Lcampos(Lcampos INT)
          |  cons_cfg_Lcampos_Campo(INT)
          ;
</ga>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%ESTRUTURAS-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Estrutura de Dados da Especificação de Configurações}
A estrutura que é gerada para o armazenamento dos campos que a gramática abstrata definiu, é dividida consoante o nível em que se está. Assim, começa-se pela estrutura que vai abranger mais campos, que neste caso corresponde ao número total de configurações, depois pela configuração, e, por último, a estrutura que vai guardar um campo para uma configuração.

\begin{lstlisting}[language=C, caption={Estrutura de dados para armazenar as configurações.}]
struct sConfs 
{ int flag;
  union {  
    struct {
        Conf s1;
        Confs s2;
      } d1;
    struct {
      } d2;
  } u;
};
\end{lstlisting}
\newpage
\begin{lstlisting}[language=C, caption={Estrutura de dados que armazena uma configuração.}]
struct sConf 
{ int flag;
  union {  
    struct {
        char * s1;
      } d1;
    struct {
        int s1;
      } d2;
    struct {
        int s1;
      } d3;
    struct {
        Lcampos s1;
      } d4;
    struct {
        int s1;
      } d5;
  } u;
};
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Estrututura de dados que armazena os campos de uma configuração.}]
struct sLcampos 
{ int flag;
  union {  
    struct {
        Lcampos s1;
        int s2;
      } d1;
    struct {
        int s1;
      } d2;
  } u;
};
\end{lstlisting}

Verifica-se aqui que cada \textsf{struct} acima apresentada deriva de cada uma das produções que foram indicadas na gramática abstrata.
As produções que foram usadas para definir a gramática abstrata são as mesmas que foram usadas para definir o \textsf{yacc}.
\newpage

\subsubsection{Assinatura das funções utilizadas}
Aqui serão apresentadas as assinaturas das funções que foram utilizadas para dar suporte à implementação do projeto desenvolvido.

\begin{lstlisting}[language=C, caption={Construtores do ficheiro de configuração.}]
/* -----------------------------------
 * Constructor Function Signatures
 * -----------------------------------
 */

Confs  cons_cfg_Confs( Conf a1, Confs a2);
Confs  cons_cfg_Confs_NIL();

Conf  cons_cfg_Conf_Titulo( char * a1);
Conf  cons_cfg_Conf_Nprovas( int a1);
Conf  cons_cfg_Conf_Ntop( int a1);
Conf  cons_cfg_Conf_Campos( Lcampos a1);
Conf  cons_cfg_Conf_Tempo( int a1);
Conf  cons_cfg_Conf_Chave( int a1);
Conf  cons_cfg_Conf_Nome( int a1);

Lcampos  cons_cfg_Lcampos_Lcampos( Lcampos a1, int a2);
Lcampos  cons_cfg_Lcampos_Campo( int a1);
\end{lstlisting} 

Os construtores da aplicação são criados automaticamente pelo \textsf{gabs}. Esta ferramenta para além de criar as estrutura de dados, cria também todos os construtores necessários para a criação da mesma.

\begin{lstlisting}[language=C, caption={Funções do ficheiro de configuração.}]
/* -----------------------------------
 * Custom Function Signatures
 * -----------------------------------
 */
void cfg_Confs_print( Confs cfgs );
int cfg_Confs_validate( Confs cfgs );
Lcampos cfg_Lcampos_reverse( Lcampos l );

// getters
int cfg_get_Nprovas( Confs cfgs );
int cfg_get_Ntop( Confs cfgs );
int cfg_get_Tempo( Confs cfgs );
int cfg_get_Chave( Confs cfgs );
int cfg_get_Nome( Confs cfgs );
char* cfg_get_Titulo( Confs cfgs );

// obtem um array de inteiros com os campos. terminado com -1
int* cfg_get_Campos( Confs cfgs );
int cfg_get_NCampos( Confs cfgs );

// obtem um array de bytes que esta a 1 nos campos que foram selecionados
char* cfg_Campos_seleccionado( Confs cfgs, int totalCampos );
\end{lstlisting} 

Embora já estejam os construtores definidos automaticamente foi necessário criar novas funções para ser possível manusear a estrutura de dados e criar funcionalidades. Deste modo, foram criadas funções que permitem ir "buscar" algum campo específico, ou fazer operações como de validação, imprimir, entre outras.

\textbf{Nota:} Foi necessário desenvolver a função \texttt{Lcampos cfg\_Lcampos\_reverse( Lcampos l )}, uma vez que a gramática definida neste programa tem recursividade à esquerda e era necessário imprimir os valores pela ordem correta, daí a necessidade da criação desta função.
\newpage
\begin{lstlisting}[language=C, caption={Funções de libertação de memória.}]
/* -----------------------------------
 * Destructor Function Signatures
 * -----------------------------------
 */
void free_cfg_Lcampos( Lcampos campos );
void free_cfg_Conf( Conf cfg );
void free_cfg_Confs( Confs cfgs );
\end{lstlisting} 

Foram implementadas funções de libertação de memória para garantir que toda a memória, que inicialmente foi criada pelo malloc, existisse um free, garantindo assim que a aplicação não tem qualquer tipo de memory leek.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%yacc-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\textsf{Yacc}}
No ficheiro do \textsf{yacc} existe, para cada produção, que seja "apanhada", uma função correspondente.

\begin{lstlisting}[language=C, caption={Yacc do ficheiro de configuração.}]
%token TITULO NPROVAS NTOP CAMPOS TEMPO CHAVE NOME str num
%{
#include <stdio.h>
#include <stdlib.h>
#include "cfg.lib.h"

#define YYERROR_VERBOSE

extern unsigned int cfglineno;
extern int cfglex (void);
extern int gco_set_Config(Confs cfg);
extern void cfglex_destroy();
%}
%union{
    char* cfg_str;
    int cfg_num;
    
    Confs cfg_confs;
    Conf cfg_conf;
    Lcampos cfg_campos;
}
%type <cfg_str> str Titulo
%type <cfg_num> num Nprovas Ntop Tempo Campo Chave Nome
%start Z

%type <cfg_confs> Z Configuracoes
%type <cfg_conf> Configuracao
%type <cfg_campos> Lcampos Campos
%%
Z : Configuracoes '$' { $$ = $1;
                        cfglex_destroy();
                        if( gco_set_Config($$) == 0 )
                            YyaccEPT;
                        YYABORT; };

Configuracoes : Configuracao '\n' Configuracoes {$$ = cons_cfg_Confs($1,$3);}
              | { $$ = cons_cfg_Confs_NIL(); }
              ;

Configuracao : Titulo  { $$ = cons_cfg_Conf_Titulo($1); }
             | Nprovas { $$ = cons_cfg_Conf_Nprovas($1); }
             | Ntop    { $$ = cons_cfg_Conf_Ntop($1); }
             | Tempo { $$ = cons_cfg_Conf_Tempo($1); }
             | Campos  { $$ = cons_cfg_Conf_Campos($1); }
             | Chave { $$ = cons_cfg_Conf_Chave($1); }
             | Nome { $$ = cons_cfg_Conf_Nome($1); }
             ;

Titulo  : TITULO str     { $$ = $2; };
Nprovas : NPROVAS num    { $$ = $2; };
Ntop    : NTOP num       { $$ = $2; };
Campos  : CAMPOS Lcampos { $$ = cfg_Lcampos_reverse( $2 ); }
Tempo   : TEMPO '$' num  { $$ = $3; };
Chave   : CHAVE '$' num  { $$ = $3; };
Nome    : NOME '$' num   { $$ = $3; };


Lcampos : Lcampos ';' Campo { $$ = cons_cfg_Lcampos_Lcampos($1,$3); }
        | Campo             { $$ = cons_cfg_Lcampos_Campo($1); }
        ;

Campo : '$' num { $$ = $2; };

%%
int yyerror( char* s ){
    fprintf(stderr, "Line %d: %s\n", cfglineno, s);
    return 0;
}
\end{lstlisting} 

Para o ficheiro de configuração o \textsf{yacc} apanha os campos relativos à configuração do ficheiro. Cada uma das produções trata de um caso específico relativo aos campos. Assim, genericamente existe um campo e uma lista de campos, sendo necessário adiciona-lo à lista, daí ser necessário existir a seguinte função: \texttt{\$\$ = cons\_cfg\_Lcampos\_Lcampos(\$1,\$3); }

A informação que o \textsf{yacc} recebe vem do processamento que o \textsf{flex} faz do ficheiro de configuração.
Quando a informação do \textsf{flex} é recebida pelo \textsf{yacc}, este apenas tem de associar as suas produções de modo a que se incluída na estrutura correta.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%lex-CONFIGUraÇÕES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\textsf{Flex}}

\begin{lstlisting}[language=C, caption={Flex utilizado para o tratamento do ficheiro de configuração.}] 
%{
#define YY_NO_INPUT
#include <string.h>
#include "cfg.lib.h"
#include "cfg.tab.h"
%}
%option nounput
%option yylineno
%x ler_string
%x ler_numero
%x ler_tempo
%x campos
%%
"=titulo="  {BEGIN ler_string; return TITULO;}
"=nprovas=" {BEGIN ler_numero; return NPROVAS;}
"=ntop="    {BEGIN ler_numero; return NTOP;}
"=campos="  {BEGIN campos;     return CAMPOS;}
"=tempo="   {BEGIN ler_numero; return TEMPO;}
"=chave="   {BEGIN ler_numero; return CHAVE;}
"=nome="    {BEGIN ler_numero; return NOME;}

<ler_string>[^\n]+ {if(*cfgtext == ' ')
                        cfglval.cfg_str = strdup(cfgtext+1);
                    else
                        cfglval.cfg_str = strdup(cfgtext);
                    BEGIN 0;
                    return str;}
<ler_numero>\$     return '$';
<ler_numero>[0-9]+ {cfglval.cfg_num = atoi(cfgtext);
                    BEGIN 0;
                    return num;}

<campos>[0-9]+ { cfglval.cfg_num = atoi(cfgtext);
                 return num;}
<campos>\$     { return '$'; }
<campos>\;     { return ';'; }
<campos>\n     { BEGIN 0; return '\n'; }

<*><<EOF>>  return '$';

[\n]+       return '\n';

<*>[ \t] ;
<*>.     { /*printf("flex: %c (%d)\n", *cfgtext, *cfgtext);*/ }

%%

int cfgwrap(){
    return 1;
}
\end{lstlisting}

A informação que o ficheiro \textsf{flex} recebe é proveniente do ficheiro de configuração.
Depois de se reconhecer os campos, estes são passados do \textsf{flex} para o \textsf{yacc} através da estrutura que é interna no \textsf{yacc}.
Por exemplo, quando se utiliza a função \texttt{cfglval.cfg\_str}, significa que se está a passar (neste caso) uma string ao campo cfg\_str da union, onde posteriormente o \textsf{yacc} irá adiciona-lo à sua estrutura.
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Especificação para a Linguagem de Comandos da Consola}
A aplicação desenvolvida possui um ambiente de consola com alguns comandos básicos:
\begin{itemize}
\item \textbf{Carregar configuração}: o sistema inicializa-se sempre com esta operação. Esta operação está sempre disponível para ser possível alterar a configuração.
\item \textbf{Carregar base de dados}: o sistema carrega para memória o estado de um torneio previamente gravado.
\item \textbf{Carregar resultado de prova}: o sistema carrega e processa um ficheiro CSV. Como resultado desta operação produz um ficheiro HTML com a pontuação de cada atleta, ordenado por ordem descente de pontos.
\item \textbf{Calcular ranking}: em qualquer momento poderá ser invocada esta operação à qual o sistema responder com uma listagem em HTML do ranking.
\item \textbf{Gravar base de dados}: o sistema guarda em memória o estado da aplicação.
\item \textbf{Imprimir}: que apresenta a informação através de uma página HTML.
\item \textbf{Save}: que guarda o estado atual do sistema.
\item \textbf{Sair}: o sistema termina a aplicação, se o estado atual não tiver sido previamente gravado deverá lançar um atleta e pedir configuração para prosseguir.
\end{itemize}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%GRAMÁTICA-CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Especificação para a Linguagem de Comandos da Consola}
A gramática que especifica a linguagem de comandos da consola é a passada ao \textsf{gabs} para depois ser gerada a estrutura usada para o funcionamento da aplicação em ambiente consola (CMD). Assim sendo tem-se:
\begin{lstlisting}[language=C, caption={Gramática para a linguagem de especificação para a linguagem de comandos de consola.}]
<ga>
  Cmds -> cons_Cmds(Cmd Cmds)
       |  cons_Cmds_NIL()
       ;

  Cmd -> cons_Cmd_Config(STR)
      |  cons_Cmd_Load(STR)
      |  cons_Cmd_Import(STR)
      |  cons_Cmd_Save(STR)
      |  cons_Cmd_FSave(STR)
      |  cons_Cmd_Print()
      |  cons_Cmd_Quit()
      |  cons_Cmd_FQuit()
      ;
</ga>
\end{lstlisting}

Esta gramática é definida depois de se ter analisado as produções que se podem ter quando estamos a tratar os comandos.

%%%%%%%%%%%%%%%%%%%%%%%%%%FUNÇÕES-CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Assinatura das funções utilizadas}
As assinaturas das funções que foram utilizadas para dar suporte à implementação do projeto, nesta fase, foram as seguintes:

\begin{lstlisting}[language=C, caption={Construtores do ficheiro de consola.}]
.h do cmd
#ifndef __CMD_LIB_H
#define __CMD_LIB_H

#include <stdlib.h>

#define CMD_PROMPT "> "

// carrega uma nova configuracao
void cmd_config(char* ficheiro);

// carrega o estado da aplicacao
void cmd_load(char* ficheiro);

// importa um CSV
void cmd_import(char* ficheiro);

// escreve o html com os dados existentes
void cmd_print();

// guarda o estado da aplicacao
void cmd_save(char* ficheiro, int force);

// sair da aplicacao
int cmd_quit();

#endif
\end{lstlisting} 

Neste caso é importante referir que quando são executadas funções \texttt{void cmd\_config(char* ficheiro)} e \texttt{void cmd\_import(char* ficheiro);} estas recebem o parser do ficheiro que lhe está associado. Se se tiver o cmd\_config o parser que será invocado será aquele que é responsável pelo ficheiro de configuração. O cmd\_import "chama" o parser que é responsável pelo ficheiro CSV.

A função \texttt{void cmd\_print();} é responsável por invocar a função que vai dar origem à página HTML pretendida.
%%%%%%%%%%%%%%%%%%%%%%%%%%yacc-CMD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\textsf{Yacc}}

No ficheiro do \textsf{yacc} cada produção que seja "apanhada" é chamada à função correspondente para tratar da operação que foi capturada.

\begin{lstlisting}[language=C, caption={Yacc do ficheiro cmd.}]
extern int cmdlex (void);
extern void cmdlex_destroy();
%}
%union{ char* cmd_ficheiro; }
%type <cmd_ficheiro> FICHEIRO
%start Comandos
%%
Comandos : Comando '\n' Comandos
         | 
         ;
Comando : Config
        | Load
        | Import
        | Print
        | Save
        | Quit
        | {/*| error  { printf("Comando invalido2.\n%s", CMD_PROMPT); yyclearin; yyerrok; }*/}
        ;

Config : CONFIG FICHEIRO { cmd_config($2); printf(CMD_PROMPT); };
       | CONFIG

Load : LOAD FICHEIRO { cmd_load($2); printf(CMD_PROMPT); };
     | LOAD

Import : IMPORT FICHEIRO { cmd_import($2); printf(CMD_PROMPT); }
       | IMPORT
       ;

Save : SAVE FICHEIRO { cmd_save($2, 0); printf(CMD_PROMPT); }
     | FSAVE FICHEIRO { cmd_save($2, 1); printf(CMD_PROMPT); }
     | SAVE
     | FSAVE
     ;

Print : PRINT { cmd_print(); printf(CMD_PROMPT); };

Quit : QUIT  { if(cmd_quit()){
                    cmdlex_destroy();
                    YyaccEPT;
               }else{
                    printf(CMD_PROMPT);
               }}
     | FQUIT { cmdlex_destroy(); YyaccEPT; }
     ;

%%
int yyerror( char* s ){
    //fprintf(stderr, "%s", s);
    return 0;
}
\end{lstlisting} 

Para além do ficheiro \textsf{yacc} criado para a especificação do ficheiro de configurações, foi necessário criar outro ficheiro \textsf{yacc} para a fazer a especificação do cmd. Assim, por exemplo, no caso de ser "apanhado" o \textsf{PRINT} é chamada a função \texttt{cmd\_print}, que vai imprimir a informação relativa aos jogadores para uma página \textsf{HTML}.

\subsubsection{\textsf{Flex}}

\begin{lstlisting}[language=C, caption={Flex do ficheiro cmd.}]
%{
#define YY_NO_INPUT
#include <string.h>
#include "cmd.tab.h"
#include "cmd.lib.h"
%}
%option nounput
%x ficheiro
%%
"config " {BEGIN ficheiro; return CONFIG;}
"c "      {BEGIN ficheiro; return CONFIG;}

"load " {BEGIN ficheiro; return LOAD;}
"l "    {BEGIN ficheiro; return LOAD;}

"import " {BEGIN ficheiro; return IMPORT;}
"i "      {BEGIN ficheiro; return IMPORT;}

"print"  return PRINT;
"p"      return PRINT;

"save! " {BEGIN ficheiro; return FSAVE;}
"s! "    {BEGIN ficheiro; return FSAVE;}
"save "  {BEGIN ficheiro; return SAVE; }
"s "     {BEGIN ficheiro; return SAVE; }

"quit"   return QUIT;
"q"      return QUIT;
"quit!" return FQUIT;
"q!"    return FQUIT;

<<EOF>>  return FQUIT;

[\n]+    { return '\n'; }

<ficheiro>[^\n]+ { /* se houver erros, tentar um duplicate aqui */
                   //cmdlval.cmd_ficheiro = strdup(cmdtext);
                   cmdlval.cmd_ficheiro = cmdtext;
                   BEGIN 0;
                   return FICHEIRO;
                 }
<ficheiro>[\n]    { BEGIN 0;
                    printf("Comando invalido6.\n%s", CMD_PROMPT);
                    return '\n'; }

 /** capturar comandos invalidos especiais **/
[clis]\n          { printf("Comando invalido1.\n%s", CMD_PROMPT); }
[^clipsq\n][^\n]* { printf("Comando invalido2.\n%s", CMD_PROMPT); }
"q"[^\n]+         { printf("Comando invalido3.\n%s", CMD_PROMPT); }
"p"[^\n]+         { printf("Comando invalido4.\n%s", CMD_PROMPT); }
"config"[^ ]      { printf("Comando invalido5.\n%s", CMD_PROMPT); }

. ;

%%

void cmd_lex_push( FILE* sav_file_import ){
    cmdpush_buffer_state(cmd_create_buffer(sav_file_import, YY_BUF_SIZE));
}

void cmd_lex_pop(){
    yypop_buffer_state();
}

int cmdwrap(){
    return 1;
}
\end{lstlisting}

O \textsf{flex} neste caso está associado ao input que é produzido pelo utilizador, isto é, no caso do cmd significa que não estamos a trabalhar com a nossa própria consola.

Devido ao facto de termos a nossa própria consola isso implica termos o parsing que reconhece os comandos que estão a ser introduzidos, para depois esses comandos serem passados ao \textsf{yacc}, que vai determinar que função é desencadeada como esse comando.

\subsection{Especificação para os Ficheiros de Resultados}
%%%%%%%%%%%%%%%%%%%%%%%%%%GRAMÁTICA-FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Gramática Especificação para os Ficheiros de Resultados}

A gramática abstrata que se segue vai ser usada para gerar a estrutura de representação intermédia para o ficheiro de resultados.

\begin{lstlisting}[language=C, caption={Gramática para a linguagem de especificação para os ficheiros de resultados.}]
<ga>
  
  Linhas -> cons_csv_Linhas(Linha Linhas)
          | cons_csv_Linhas_NIL()
          ;

  Linha -> cons_csv_Linha(Linha Campo)
        | cons_csv_Linha_Fim(Campo)
        ;

  Campo -> cons_csv_Campo(STR)
        | cons_csv_Campo_NIL()
        ;
 </ga>
\end{lstlisting}

As produções que se podem encontrar na gramática abstrata são provenientes da definição de produções a que consideramos importantes para tratar a informação que pode ser encontrada num ficheiro de resultados.

%%%%%%%%%%%%%%%%%%%%%%%%%%ESTRUTURA DE DADOS -FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Estrutura de Dados da Especificação dos Ficheiros de Resultados}

A estrutura que é gerada para o armazenamento dos campos que a gramática abstrata definiu, é dividida consoante o nível em que estamos. Assim, se começarmos por ter a estrutura que vai abranger mais campos, que neste caso, corresponde ao total de linhas que constituem o ficheiro, significa que depois teremos o que é uma linha e por último a estrutura que vai guardar um campo.

\begin{lstlisting}[language=C, caption={Estrutura de dados para armazenar a especificação dos ficheiros de resultados.}]

/* --- Linhas ---*/
struct sLinhas 
{ int flag;
  union {  
    struct {
        Linha s1;
        Linhas s2;
      } d1;
    struct {
      } d2;
  } u;
};

/* --- Linha ---*/
struct sLinha 
{ int flag;
  union {  
    struct {
        Linha s1;
        Campo s2;
      } d1;
    struct {
        Campo s1;
      } d2;
  } u;
};

/* --- Campo ---*/
struct sCampo 
{ int flag;
  union {  
    struct {
        char * s1;
      } d1;
    struct {
      } d2;
  } u;
};

\end{lstlisting}

\subsubsection{Assinatura das funções utilizadas}
Nesta secção serão apresentadas as assinaturas das funções que foram utilizadas para dar suporte à implementação do projeto.

\begin{lstlisting}[language=C, caption={Construtores do ficheiro de resultados.}]

/* -----------------------------------
 * Constructor Function Signatures
 * -----------------------------------
 */

Linhas  cons_csv_Linhas( Linha a1, Linhas a2);
Linhas  cons_csv_Linhas_NIL();

Linha  cons_csv_Linha( Linha a1, Campo a2);
Linha  cons_csv_Linha_Fim( Campo a1);

Campo  cons_csv_Campo( char * a1);
Campo  cons_csv_Campo_NIL();


/* -----------------------------------
 * Custom Function Signatures
 * -----------------------------------
 */
void csv_print( Linhas csv );
Linha csv_Linha_reverse( Linha l );
int csv_Linhas_validate (Linhas lcsv);

void csv_import_csv( Linhas dados );
int csv_tempo_to_int(char* str);

// indice_campo comeca em 1
char* csv_get_campo(Linha campos, int indice_campo);

/* -----------------------------------
 * Destructor Function Signatures
 * -----------------------------------
 */

void csv_free_ListaCSV(Lcsv elem);
void free_csv_Campo (Campo cmp);
void free_csv_Linha (Linha l);
void free_csv_Linhas (Linhas lcsv);

\end{lstlisting} 

Nesta secção são apresentadas as assinaturas das funções que são usadas, tanto para fazer a inicialização das estrutura de dados (criadas pelo \textsf{gabs}), quer como as funções que foram necessárias definir, de modo a ser possível efetuar operações sobre as mesmas.

Para além das funções que são responsáveis por fazer a libertação de toda a memória que foi utilizada, temos a função \texttt{Linha csv\_Linha\_reverse( Linha l );} que é utilizada para imprimir a forma como os campos foram lidos. Esta função é necessária devido ao facto de se ter definido uma gramática com recursividade à esquerda.

\newpage

\subsubsection{\textsf{Yacc}}
%%%%%%%%%%%%%%%%%%%%%%%%%%yacc-FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
No ficheiro do \textsf{yacc} cada produção que seja "apanhada" é sempre chamada a função correspondente para tratar o caso que foi apanhado.

\begin{lstlisting}[language=C, caption={Yacc do ficheiro de resultados.}]

%token str
%{
#include <stdio.h>
#include <stdlib.h>
#include "csv.lib.h"

#define YYERROR_VERBOSE

extern unsigned int csvlineno;
extern int csvlex (void);
extern void csvlex_destroy();
%}
%union{
  char * csv_str;
  
  Linhas csv_Linhas;
  Linha  csv_Linha;
  Campo  csv_Campo;
} 

%type<csv_str> str
%type<csv_Campo> Campo
%type<csv_Linhas> X Linhascsv
%type<csv_Linha> Linha
%start X

%%
X : Linhascsv '$' { $$ = $1; 
                    csvlex_destroy();
                    if( csv_Linhas_validate($$) ){
                        csv_import_csv($$);
                        YyaccEPT;
                    }else{
                        YYABORT;
                    }
                  };

Linhascsv : Linha '\n' Linhascsv {$1 = csv_Linha_reverse($1);
                                  $$ = cons_csv_Linhas ($1,$3);}
          | {$$ = cons_csv_Linhas_NIL();}
          ;

Linha : Linha ';' Campo {$$ = cons_csv_Linha ($1,$3);}
      | Campo {$$ = cons_csv_Linha_Fim ($1);}
      ;

Campo : str {$$ = cons_csv_Campo ($1);}
      | {$$ = cons_csv_Campo_NIL();}
      ;

%%
int yyerror( char* s ){
    fprintf(stderr, "Line %d: %s\n", csvlineno, s);
    return 0;
}
\end{lstlisting}

A informação que o \textsf{yacc} recebe vem do processamento que o \textsf{flex} faz do ficheiro de configuração que é passado ao \textsf{flex}.
Quando a informação do \textsf{flex} é recebida pelo \textsf{yacc}, este apenas tem de a associar a uma das suas produções de modo a ser incluída na estrutura correta.
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%lex-FICHEIROS-DE-RESULTADOS-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\textsf{Flex}}

\begin{lstlisting}
%{
#define YY_NO_INPUT
#include <string.h>
#include "csv.lib.h"
#include "csv.tab.h"
%}
%option yylineno
%option nounput

%%
[^\n\;]+ {csvlval.csv_str = strdup(csvtext);
         return str;}
\n+     {return '\n';}
\;      {return ';';}
<<EOF>> {return '$';}

%%
int csvwrap(){
  return 1;
}
\end{lstlisting}

O \textsf{flex} relativo ao parsing do fihceiro CSV é relativamente simples, isto deve-se ao facto de se ter definido que todos os campos do ficheiro são strings, assim sendo o único tratamento que é necessário fazer aqui e o de ver onde acaba cada string, o tratamento dos \\n, a forma de separação de cada campo e por fim o EOF.

Com esta implementação o \textsf{yacc} é responsável por decidir o modo como se irá tratar cada campo que recebe do \textsf{flex}.
 
\newpage
\subsection{Tratamento da Informação do Atleta}

Um dos requisitos necessários para o desenvolvimento da plataforma era o cálculo da pontuação dos atletas. 

Uma vez que existem vários atletas foi necessário a criação de uma estrutura que nos permitisse guardar a informação de cada uma dos atletas que participam no Campeonato Orientação.

Essa estrutura é então composta por:
\begin{itemize}
\item \textsf{ID}: identificador de atleta;
\item \textsf{nome}: nome do atleta;
\item \textsf{score}: lista de ponto obtidos em cada prova;
\item \textsf{tempo\_ultima\_prova}: tempo que o atleta obteve na última prova decorrida.
\end{itemize}

Para além de termos a informação do atleta foi necessário implementar também uma estrutura que permitisse guardar todos os atletas que participam numa prova.

Assim sendo as estruturas implementadas foram as seguintes:

\begin{lstlisting}[language=C, caption={Estrutura de um atleta.}]
struct sLInt {
    LInt proximo;
    int num;};

struct sAtletas{
    Atletas proximo;
    Atleta atleta;};

struct sAtleta{
    char* ID;
    char* nome;
    LInt scores;
    int tempo_ultima_prova;};
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Assinatura das funções.}]
Atleta atl_novo_atleta(char* id, char* nome);
void atl_add_score(Atleta atleta, int score);
int atl_get_score(Atleta atleta, int nTop);

Atletas atl_ordenar_por_Score(Atletas atletas);
Atletas atl_insere_por_ID(Atletas atletas, Atleta atleta);
Atletas atl_insere_por_Score(Atletas atletas, Atleta atleta);

void atl_print(Atletas atletas);
void atl_free_Atletas(Atletas atletas);

// versao que nao liberta memoria dos atletas em si (apenas da lista)
// usado para libertar a lista ordenada por score
void atl_free_AtletasList(Atletas atletas);
void atl_free_Atleta(Atleta atleta);
void atl_free_Scores(LInt scores);

/******************
 * Ler dados dos atletas a partir do csv
 * ***************/

Atletas atl_ler_csv( Confs cfg, Linhas csv, Atletas atletas );
Atletas atl_ler_tempos( Confs cfg, Linhas csv, Atletas atletas );
#endif
\end{lstlisting}

O tratamento desta informação serve para se poder analisar e processar os rankings das pontuações dos atletas. Deste modo, um dos requisitos necessários para processar foi os tempos obtidos por cada jogador de forma, a que mais tarde, fosse possível criar no HTML dos rankings de provas, atletas, etc.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%HTML%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{HTML}

Um dos resultados finais deste projeto é gerar uma página HTML que permita evidenciar o ranking das provas e também é mais uma forma de apresentação do resultados obtidos.

\begin{lstlisting}[language=C, caption={Assinatura das funções.}]
void htm_print_indice();
void htm_print_provas();
void htm_print_resultados();
int htm_begin();
void htm_end();
\end{lstlisting}

Como a criação de um ficheiro HTML era necessário ter um cuidado especial e foi preciso definir o HTMl por partes.
Assim, a apresentação do HTML parte por ter um índice para os rankings que poderá ser visível ao longo da página, seguindo, então, pelos respetivos rankings dos atletas no campeonato.

\newpage
\section{Conclusão}

Após concluir todo o desenvolvimento deste segundo projeto, de Processamento de Linguagens, é fácil fazer um balanço de todo este percurso realizado. Para além de ter sido um desafio implementar um programa de processamento de Gestão de Campeonatos de Orientação, que se aplica ao contexto da vida real, foi também aliciante concluir o trabalho e todas as etapas que foram propostas.
Ao longo do desenvolvimento do projeto o grupo desenvolveu competências em diversas ferramentas como \textsf{C}, HTML, \textsf{flex}, \textsf{yacc}, gramáticas independentes do contexto, que serão uma mais valia para o mercado de trabalho e para a vida profissional. 


\newpage
\section{Anexos}

\subsection{Makefile}

\begin{lstlisting}[language=C, caption={Makefile}]
.PHONY: clean

GDB=-Wall -g

#----------------\
#  Tokenizers    \
#----------------\

cmdtok : cmd.tok.c lex.cmd.o cmd.tab.o cmd.lib.o cmd.mockups.o
	gcc $(GDB) -o $@ $^ -ll

cfgtok : cfg.tok.c lex.cfg.o cfg.tab.o cfg.lib.o
	gcc $(GDB) -o $@ $^ -ll

csvtok : csv.tok.c lex.csv.o csv.tab.o csv.lib.o
	gcc $(GDB) -o $@ $^ -ll

#----------------\
#  Gco           \
#----------------\

gco : gco.lib.c sav.lib.o htm.lib.o atl.lib.o cfg.lib.o lex.cfg.o cfg.tab.o cmd.lib.o lex.cmd.o cmd.tab.o csv.lib.o lex.csv.o csv.tab.o
	gcc $(GDB) -o $@ $^
	cp gco ../bin/gco

htm.lib.o : htm.lib.c htm.lib.h cfg.lib.h csv.lib.h
	gcc $(GDB) -c htm.lib.c

atl.lib.o : atl.lib.c atl.lib.h cfg.lib.h csv.lib.h
	gcc $(GDB) -c atl.lib.c

sav.lib.o : sav.lib.c sav.lib.h
	gcc $(GDB) -c sav.lib.c

#----------------\
#  Cfg           \
#----------------\

cfg : cfg.main.c cfg.lib.o lex.cfg.o cfg.tab.o
	gcc $(GDB) -o $@ $^ -ll

cfg.lib.o : cfg.lib.c cfg.lib.h
	gcc $(GDB) -c cfg.lib.c

cfg.tab.o : cfg.tab.h cfg.tab.c
	gcc $(GDB) -c cfg.tab.c

lex.cfg.o : lex.cfg.c cfg.tab.h cfg.lib.o
	gcc $(GDB) -c lex.cfg.c -ll

cfg.tab.c cfg.tab.h : cfg.y cfg.lib.o
	yacc -d -pcfg -bcfg cfg.y

lex.cfg.c : cfg.l
	flex -Pcfg cfg.l

#----------------\
#  Cmd           \
#----------------\

cmd : cmd.main.c cmd.lib.o lex.cmd.o cmd.tab.o cmd.mockups.o
	gcc $(GDB) -o $@ $^ -ll

cmd.mockups.o : cmd.mockups.c cmd.mockups.h
	gcc $(GDB) -c cmd.mockups.c

cmd.lib.o : cmd.lib.c cmd.lib.h
	gcc $(GDB) -c cmd.lib.c

cmd.tab.o : cmd.tab.h cmd.tab.c
	gcc $(GDB) -c cmd.tab.c

lex.cmd.o : lex.cmd.c cmd.tab.h
	gcc $(GDB) -c lex.cmd.c -ll

cmd.tab.c cmd.tab.h : cmd.y cmd.lib.h
	yacc -d -pcmd -bcmd cmd.y

lex.cmd.c : cmd.l
	flex -Pcmd cmd.l


#----------------\
#  CSV           \
#----------------\

csv : csv.main.c csv.lib.o lex.csv.o csv.tab.o
	gcc $(GDB) -o $@ $^ -ll

csv.lib.o : csv.lib.c csv.lib.h
	gcc $(GDB) -c csv.lib.c

csv.tab.o : csv.tab.h csv.tab.c
	gcc $(GDB) -c csv.tab.c

lex.csv.o : lex.csv.c csv.tab.h
	gcc $(GDB) -c lex.csv.c -ll

csv.tab.c csv.tab.h : csv.y csv.lib.h
	yacc -d -pcsv -bcsv csv.y

lex.csv.c : csv.l
	flex -Pcsv csv.l
#----------------\
#  Extras        \
#----------------\

clean :
	$(RM) gabs
	$(RM) gco
	$(RM) cmd
	$(RM) cfg
	$(RM) csv
	$(RM) *.o
	$(RM) *.tab.[ch]
	$(RM) lex.*.c
	$(RM) *tok

gabs:
	cd ./../gabs/ && $(MAKE) gabs && mv ./gabs ./../src/gabs

\end{lstlisting}
\newpage

\section{Elementos do Grupo}
\begin{figure}[h!]
\centering
\begin{subfigure}{.33\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{60}
  \caption{Bruno Ferreira  }
\end{subfigure}%
\begin{subfigure}{.33\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{107}
  \caption{Cláudia Oliveira}
\end{subfigure}%
\begin{subfigure}{.33\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{93}
  \caption{Vanessa Campos}
\end{subfigure}%
\end{figure}



\end{document}